<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/通知优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/15/通知优化/" itemprop="url">
                  通知优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-15T19:39:56+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在对项目中的Notification和短链跳转进行优化，APP退出之后，从外部进入目标页面，避免直接返回到桌面。Android系统采用任务栈来管理Activity。</p>
<p><img src="../images/notification/backstack.png" alt="任务栈"></p>
<p>目前返回是统一指向主页面，实现方式无非是两种：一是先启动再跳转，二先跳转目标页然后返回主页。</p>
<p>具体方案如下：</p>
<h2 id="一、TaskStackBuilder"><a href="#一、TaskStackBuilder" class="headerlink" title="一、TaskStackBuilder"></a>一、TaskStackBuilder</h2><p>用于构造返回任务栈，仅支持22以上的版本。<br>在AndroidManifest.xml配置Activity关系</p>
<pre><code>&lt;activity android:name=&quot;.NoticesActivity&quot;
      android:parentActivityName=&quot;.HomeActivity&quot;/&gt;
</code></pre><p>系统会读取该属性，以确定当用户返回时应该启动哪一个Activity。</p>
<p>代码</p>
<pre><code>//启动通知Activity时，拉起主页面Activity
Intent noticeIntent = new Intent();
noticeIntent.setClass(this, NoticesActivity.class);

//创建返回栈
TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);
//添加Activity到返回栈
stackBuilder.addParentStack(HomeActivity.class);
//添加Intent到栈顶
stackBuilder.addNextIntent(noticeIntent);

PendingIntent pendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);
</code></pre><h2 id="二、PendingIntent-getActivities"><a href="#二、PendingIntent-getActivities" class="headerlink" title="二、PendingIntent.getActivities()"></a>二、PendingIntent.getActivities()</h2><p>先看看官方的解释：</p>
<p><img src="../images/notification/getActivities.jpeg" alt="getActivities"></p>
<p>首先需要构建一个Intent数组，其中第一个Intent对象将会被额外的启动一个栈（启动模式设置为singleTask），所以将HomeActivity设置为intents[0]对象.</p>
<p>而intents数组中最后一个，将作为PendIntent的关键，也就是点击之后需要跳转的目标页面。</p>
<p>代码：</p>
<pre><code>Intent noticeIntent = new Intent();
Intent homeIntent = new Intent();
noticeIntent.setClass(this, NoticesActivity.class);
homeIntent.setClass(this, HomeActivity.class);
//按顺序排列
Intent[] intents = new Intent[]{homeIntent, noticeIntent};
PendingIntent pendingIntent = PendingIntent.
        getActivities(this, 0, intents, PendingIntent.FLAG_UPDATE_CURRENT);
</code></pre><h2 id="三、启动多个页面"><a href="#三、启动多个页面" class="headerlink" title="三、启动多个页面"></a>三、启动多个页面</h2><p>1、过渡页中一次性启动多个页面</p>
<pre><code>Intent[] intents = {homeIntent, noticeIntent};
context.startActivities(intents);
</code></pre><p>2、在页面中依次按顺序启动页面，并管理传入的参数，实现不同目标页的跳转（稍微复杂）</p>
<h2 id="四、加一个flag，重构返回逻辑（实现简单）"><a href="#四、加一个flag，重构返回逻辑（实现简单）" class="headerlink" title="四、加一个flag，重构返回逻辑（实现简单）"></a>四、加一个flag，重构返回逻辑（实现简单）</h2><p>代码：</p>
<pre><code>Intent msgIntent =new Intent(context,ProjectDetailHomeActivity.class);
//判断是否是点击notification后到的详细界面
startIntent.putExtra(&quot;notificationFlag&quot;,true);
</code></pre><p>重写BaseActivity的返回逻辑</p>
<pre><code>notificationFlag =intent.getBooleanExtra(&quot;notificationFlag&quot;,false);
if(notificationFlag){
     Intent intent=new Intent(this,MainActivity.class);
     startActivity(intent);
     finish();
}
</code></pre><p>也可以重写Activity的onBackPressed（）方法，判断当前Activity是否处于任务栈的底部，如果是则跳转首页，否则正常返回。</p>
<blockquote>
<p>注意：为了确保Activity处于栈底，应该把启动模式设置为singleTask。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在项目中无法直接打开目标详情页，中间还需经过一个过度组件来准备数据，和相关初始化工作（权限、网络通信、状态更新、未登录等），所以方案一、二排除。由于通知类型较多，需要改造较多的目标页面，并对不同的flag进行管理，方案三实现略微复杂。最后采用了方案四！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/注解的那些事/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/24/注解的那些事/" itemprop="url">
                  注解的那些事
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-24T19:55:53+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是注解（Annotation）？"><a href="#什么是注解（Annotation）？" class="headerlink" title="什么是注解（Annotation）？"></a>什么是注解（Annotation）？</h1><p><strong>首先要回答为啥要使用注解？它能解决什么样的问题？</strong></p>
<blockquote>
<p>简单来说它能告诉编译器按我们的意图做一些事情，具有标识、减少代码量，让代码结构更加清晰的作用。</p>
</blockquote>
<p>For example，在Android开发过程中，要获取一个控件对象必须大量调用 findViewById()方法，并且还的进行类型强转，使用起来非常麻烦。</p>
<p>为了解决这个问题ButterKnife应运而生，只需添加一行注解便能实现xml控件的绑定。<br>除此之外，Retrofit、Rxjava、OKHttp等开源项目也大量使用了注解。</p>
<p><strong>总结一下,注解就是Java提供了一种源程序中的元素关联任何信息或者任何元数据（metadata）的途径和方法</strong>。</p>
<blockquote>
<p>它是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
</blockquote>
<p>常见的作用有以下几种：</p>
<ul>
<li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能。（retrofit网络配置）</li>
<li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</li>
</ul>
<h1 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h1><p>JDK1.5开始，Java提供了注解的功能，允许开发者定义和使用自己的注解类型，该功能由一个定义注解类型的语法和描述一个注解声明的语法，读取注解的API，一个使用注解修饰的class文件和一个注解处理工具组成。整个过程包括：注解定义、使用注解、初始化注解处理、处理注解。</p>
<h2 id="注解类型"><a href="#注解类型" class="headerlink" title="注解类型"></a>注解类型</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p> 元注解是指注解的注解。包括  @Retention @Target @Document @Inherited四种。</p>
<p><strong>1、@Retention: 定义注解的保留策略</strong></p>
<pre><code>@Retention(RetentionPolicy.SOURCE)//注解仅存在于源码中，在class字节码文件中不包含
@Retention(RetentionPolicy.CLASS)// 默认的保留策略，注解会在class字节码文件中存在，但运行时无法得
@Retention(RetentionPolicy.RUNTIME)// 注解会在class字节码文件中存在，在运行时可以通过反射获取到
</code></pre><p><strong>2、@Target：定义注解的作用目标</strong></p>
<p>其定义的源码为： </p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
 public @interface Target {
     ElementType[] value();
 }
@Target(ElementType.TYPE)   //接口、类、枚举、注解
@Target(ElementType.FIELD) //字段、枚举的常量
@Target(ElementType.METHOD) //方法
@Target(ElementType.PARAMETER) //方法参数
@Target(ElementType.CONSTRUCTOR)  //构造函数
@Target(ElementType.LOCAL_VARIABLE)//局部变量
@Target(ElementType.ANNOTATION_TYPE)//注解
@Target(ElementType.PACKAGE) ///包   
</code></pre><p>由以上的源码可以知道，他的elementType 可以有多个，一个注解可以为类的，方法的，字段的等等。</p>
<p><strong>3、@Document：说明该注解将被包含在javadoc中</strong></p>
<p><strong>4、@Inherited：说明子类可以继承父类中的该注解</strong></p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>Java中表示声明一个注解类的关键字。<br>使用@interface 表示我们已经继承了java.lang.annotation.Annotation类，这是一个注解的基类接口</p>
<pre><code>public @interface MyAnnotation { 

}
</code></pre><p>通常在使用时会为注解类加上两个注解：</p>
<pre><code>@Target(ElementType.TYPE,ElementType.METHOD)、
@Retention(RetentionPolicy.RUNTIME)
</code></pre><p>表示注解会在class字节码文件中存在，在运行时可以通过反射获取到。同时，该注解可以是类的注解或者方法的注解。</p>
<p>Annotation类型里面的参数设定: </p>
<ul>
<li>只能用public或默认(default)这两个访问权修饰.</li>
<li>成员变量只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String,Enum,Class,annotations等数据类型,以及这一些类型的数组。</li>
<li>成员变量以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。如果只有一个成员变量,最好把成员变量名称设为value.</li>
</ul>
<p>例如ButterKnife中 BindView注解的申明：</p>
<pre><code>@Retention(CLASS) @Target(FIELD)
public @interface BindView {
  /** View ID to which the field will be bound. */
  @IdRes int value();
}
</code></pre><h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><p>根据所标识的注解完成未完成的工作</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>利用Java的反射机制，但是运行时效率低下，因为JVM不能够在反射之前做任何假象和优化，另外在参数检查、可见性检查、调用权限、分配内存等方面仍然要占用更多的时间。如下代码实现了对象与控件的绑定：</p>
<pre><code>/**

 * @param currentClass

 *            当前类，一般为Activity或Fragment

 * @param sourceView

 *            待绑定控件的直接或间接父控件

 */

public static void initBindView(Object currentClass, View sourceView) {

    // 通过反射获取到全部属性，反射的字段可能是一个类（静态）字段或实例字段

    Field[] fields = currentClass.getClass().getDeclaredFields();

    if (fields != null &amp;&amp; fields.length &gt; 0) {

        for (Field field : fields) {

            // 返回BindView类型的注解内容

            BindView bindView = field.getAnnotation(BindView.class);

            if (bindView != null) {

                int viewId = bindView.id();

                boolean clickLis = bindView.click();

                try {

                    field.setAccessible(true);

                    if (clickLis) {

                        sourceView.findViewById(viewId).setOnClickListener(

                                (OnClickListener) currentClass);

                    }

                    // 将currentClass的field赋值为sourceView.findViewById(viewId)

                    field.set(currentClass, sourceView.findViewById(viewId));

                } catch (Exception e) {

                    e.printStackTrace();

                }

            }

        }

    }

}
</code></pre><h3 id="APT-Annotation-Processing-Tool"><a href="#APT-Annotation-Processing-Tool" class="headerlink" title="APT(Annotation Processing Tool)"></a>APT(Annotation Processing Tool)</h3><ul>
<li>注解处理器（AbstractProcess）</li>
<li>代码处理（JavaPoet库）</li>
<li>处理器注册（AutoService）</li>
<li><p>annotationProcessor(Android官方插件,在编译期间自动生成的代码,不会降低运行效率）</p>
<blockquote>
<p>Annotation处理器根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。</p>
</blockquote>
<p>常见的项目： Dagger2 、 ButterKnife<br><a href="http://blog.csdn.net/xx326664162/article/details/68490059" target="_blank" rel="external">http://blog.csdn.net/xx326664162/article/details/68490059</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>EventBus、Retrofit 属于反射，反射可以动态访问和修改对象，让代码更加灵活，处理不当会对性能造成影响。在如今硬件设备上，牺牲部分性能并不会影响用户体验。在实际项目中，可以考虑开发埋点注解框架，减少使用者的学习成本和出错率。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/26/进程保活/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/26/进程保活/" itemprop="url">
                  进程保活是耍流氓吗？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-26T19:30:23+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>保活是不是耍流氓？</strong></p>
<p>很多场景如果要想为用户服务，就必须有一个进程常驻，以便在特定的时候做特定的事情。</p>
<p>1、实现IM，推送，定位等功能。</p>
<p>2、某些系统广播无法静态注册。</p>
<blockquote>
<p>android.intent.action.SCREEN_ON</p>
<p>android.intent.action.SCREEN_OFF</p>
<p>android.intent.action.BATTERY_CHANGED</p>
<p>android.intent.action.CONFIGURATION_CHANGED</p>
<p>android.intent.action.TIME_TICK</p>
</blockquote>
<p>存在问题：<br>增加系统性能开销，所以结合内存、电池等消耗找到一个平衡点。</p>
<p>Android系统中在没有白名单的情况下，要做到应用不被杀死基本不可能的，但是我们可以让应用尽可能的不被杀死，如果杀死也能够自动复活。</p>
<h1 id="Android进程的优先级"><a href="#Android进程的优先级" class="headerlink" title="Android进程的优先级"></a>Android进程的优先级</h1><p>1、前台进程(Foreground process)</p>
<ul>
<li>某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。 </li>
<li>某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。 </li>
<li>某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。 </li>
<li>某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。 </li>
<li>某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。</li>
</ul>
<p>表示用户正在使用的程序，一般系统是不会杀死前台进程的，除非用户强制停止应用或者系统内存不足等极端情况会杀死。</p>
<p>2、可见进程(Visible process)</p>
<ul>
<li>拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。 </li>
<li>拥有绑定到可见（或前台）Activity 的 Service</li>
</ul>
<p>用户仅仅可见，无法交互！<br>一般系统也是不会杀死可见进程的，除非要在资源吃紧的情况下，要保持某个或多个前台进程存活</p>
<p>3、服务进程(Service process)</p>
<ul>
<li>某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。</li>
</ul>
<p>在内存不足以维持所有前台进程和可见进程同时运行的情况下，服务进程会被杀死</p>
<p>4、后台进程(Background process)</p>
<ul>
<li>在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onStop方法</li>
</ul>
<p>系统可能随时终止它们，回收内存</p>
<p>5、空进程(Empty process)</p>
<ul>
<li>某个进程不包含任何活跃的组件时该进程就会被置为空进程，</li>
</ul>
<p>完全没用,直接干掉</p>
<h1 id="Android进程的回收策略"><a href="#Android进程的回收策略" class="headerlink" title="Android进程的回收策略"></a>Android进程的回收策略</h1><p>系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app, 这套杀进程回收内存的机制就叫<strong>Low Memory Killer</strong>，位于kernel层。</p>
<p>不同手机的内存阈值也不同，可以通过cat /sys/module/lowmemorykiller/parameters/minfree文件查看，一旦低于该值,Android便开始按顺序关闭进程。因此Android最先结束优先级最低的空进程。</p>
<p>进程的优先级是通过进程的oom_adj值来反映的。Linux内核为每个系统进程分配了一个oom_adj值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收，oom_adj值定义在com.android.server.am.ProcessList类中。</p>
<table>
<thead>
<tr>
<th>adj级别</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNKNOWN_ADJ</td>
<td>16</td>
<td>预留的最低级别，一般对于缓存的进程才有可能设置成这个级别</td>
</tr>
<tr>
<td>CACHED_APP_MAX_ADJ</td>
<td>15</td>
<td>缓存进程，空进程，在内存不足的情况下就会优先被kill</td>
</tr>
<tr>
<td><strong>CACHED_APP_MIN_ADJ</strong></td>
<td>9</td>
<td>缓存进程，也就是空进程</td>
</tr>
<tr>
<td><strong>SERVICE_B_ADJ</strong></td>
<td>8</td>
<td>不活跃的进程</td>
</tr>
<tr>
<td>PREVIOUS_APP_ADJ</td>
<td>7</td>
<td>切换进程</td>
</tr>
<tr>
<td>HOME_APP_ADJ</td>
<td>6</td>
<td>与Home交互的进程</td>
</tr>
<tr>
<td><strong>SERVICE_ADJ</strong></td>
<td>5</td>
<td>有Service的进程</td>
</tr>
<tr>
<td>HEAVY_WEIGHT_APP_ADJ</td>
<td>4</td>
<td>高权重进程</td>
</tr>
<tr>
<td>BACKUP_APP_ADJ</td>
<td>3</td>
<td>正在备份的进程</td>
</tr>
<tr>
<td><strong>PERCEPTIBLE_APP_ADJ</strong></td>
<td>2</td>
<td>可感知的进程，比如那种播放音乐</td>
</tr>
<tr>
<td><strong>VISIBLE_APP_ADJ</strong></td>
<td>1</td>
<td>可见进程</td>
</tr>
<tr>
<td><strong>FOREGROUND_APP_ADJ</strong></td>
<td>0</td>
<td>前台进程</td>
</tr>
<tr>
<td>PERSISTENT_SERVICE_ADJ</td>
<td>-11</td>
<td>重要进程</td>
</tr>
<tr>
<td>PERSISTENT_PROC_ADJ</td>
<td>-12</td>
<td>核心进程</td>
</tr>
<tr>
<td>SYSTEM_ADJ</td>
<td>-16</td>
<td>系统进程</td>
</tr>
<tr>
<td>NATIVE_ADJ</td>
<td>-17</td>
<td>系统起的Native进程</td>
</tr>
</tbody>
</table>
<p>oom_adj的值越小，进程的优先级越高，普通进程oom_adj值是大于等于0的，而系统进程oom_adj的值是小于0的，第三方应用一般只能干掉4以上的进程。我们可以通过<strong>ps|grep</strong>和<strong>cat /proc/process id/oom_adj</strong>查看当前进程的oom_adj值。</p>
<h1 id="常见的几种保活方案"><a href="#常见的几种保活方案" class="headerlink" title="常见的几种保活方案"></a>常见的几种保活方案</h1><h2 id="防止被杀死"><a href="#防止被杀死" class="headerlink" title="防止被杀死"></a>防止被杀死</h2><ul>
<li><p>降低oom_adj的值，提高进程优先级，减少内存占用。<br>如锁屏时候进程中开启一个像素的透明Activity，这样进程变为前台进程防止被杀死。</p>
</li>
<li><p>前台服务，使用Android的一个通知栏的bug，调用startForegound发送一个空的notification，在通知栏没有任何通知，而且进程同样处于低oom_adj状态。4.3以后通过开两个service绑定到同一个通知ID，然后干掉其中一个移除通知显示，保留前台服务（Android7.1修复了这个漏洞）。</p>
</li>
</ul>
<ul>
<li>业务多进程实现，保持单进程最小内存占用，增大存活几率。目前主流应用大多采用多进程的方式</li>
</ul>
<h2 id="如何拉活"><a href="#如何拉活" class="headerlink" title="如何拉活"></a>如何拉活</h2><p><strong>1、利用系统广播拉活（ 开机、网络变化、文件挂载等）</strong></p>
<blockquote>
<p>缺点：可能被安全软件禁用，不可控，不能保证立即拉活（程序被强制干掉，不会接收到广播）。同时,Android N删除了三项隐式广播，后续不排除会删除其他系统广播，所以在开发过程中应该减少对系统广播的依赖。</p>
<p>解决：第三方相互唤醒，很多大厂都采用该方案。</p>
</blockquote>
<p><strong>2、利用系统service机制拉活。</strong><br>onStartCommand方法必须具有一个整形的返回（START_STICKY），这个整形的返回值用来告诉系统在服务启动完毕后，被杀死后对应的操作。也可以在onDestroy方法中重建。</p>
<blockquote>
<p>缺点：<br>1、内存不足，回收后，尝试重新创建。<br>2、多次kill后不会拉活。<br>3、强制kill后 不会重启</p>
</blockquote>
<p><strong>3、进程守护。</strong><br>利用native进程拉活（5.0后不可靠，主进程和子进程一起杀死）</p>
<ul>
<li>fork新进程进行守护，轮训定时器判断</li>
<li>主进程中创建监控并持有文件锁，新进程中申请文件锁被阻塞 ，获得锁则拉活.</li>
</ul>
<blockquote>
<p>解决：可以想办法让子进程脱离主进程所属进程组，切断联系。<a href="http://blog.csdn.net/yyh352091626/article/details/50542554" target="_blank" rel="external">http://blog.csdn.net/yyh352091626/article/details/50542554</a></p>
</blockquote>
<p><strong>4、JobSheduler机制拉活（5.0后的替代方案）</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上几种保活方案并不是完全可靠，只能降低被杀死的概率。系统有自己特定的进程管理方式，官方不推荐使用各类保活手段，除非强烈的产品需求，各种利用系统漏洞的保活方案一定要慎用，保活会产生一些性能和电量的消耗，甚至引发不可预知的风险。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/05/Android系统下编译模式的演变/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/Android系统下编译模式的演变/" itemprop="url">
                  Android系统下编译模式的演变
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-05T09:28:18+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java的执行方式"><a href="#Java的执行方式" class="headerlink" title="Java的执行方式"></a>Java的执行方式</h1><p>Java虚拟机有3种执行方式，分别是解释执行、编译执行和混合模式，默认情况下处于混合模式中。使用命令行java –version可以查看虚拟机的执行模式。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/Java%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F.jpg" alt="Java编译模式"></p>
<ul>
<li><p>interpreted mode表示解释执行模式，全部代码均解释执行。</p>
</li>
<li><p>compiled mode表示编译执行模式，和解释执行模式相反，对于所有的方法，无论是否是热点代码，都会被编译执行。</p>
</li>
<li><p>mixed mode表示混合模式，部分代码会被解释执行，也可能被编译执行。虚拟机决定热点（高频、反复使用）代码是否需要编译执行。</p>
</li>
</ul>
<h1 id="什么是JIT和AOT"><a href="#什么是JIT和AOT" class="headerlink" title="什么是JIT和AOT"></a>什么是JIT和AOT</h1><h2 id="JIT（Just-in-time）"><a href="#JIT（Just-in-time）" class="headerlink" title="JIT（Just-in-time）"></a>JIT（Just-in-time）</h2><p>JIT属于动态编译编译器，通常也被称为即时编译器。Java虚拟机默认使用的编译技术，也就是前面提到的混合编译模式，相比于解释执行全部字节码的效率低下，编译执行不加区分的编译转化成机器码。而混合模式较好的结合了二者的优势，对部分热点代码进行编译优化，在执行效率上接近C/C++。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/jit%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.jpg" alt="jit工作过程"></p>
<p>从图中看出整个执行过程如下：</p>
<p>1、源代码经javac编译成字节码，即class文件</p>
<p>2、字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等）</p>
<p>3、如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码</p>
<p>4、如否，则直接由解释器解释执行</p>
<p>5、操作系统及类库调用</p>
<p>6、硬件</p>
<blockquote>
<p>运行时会将JIT编译过的机器码保存起来，第二次直接执行，但是识别热点代码也需要一个准备的过程。同时，对于部分只会被执行一次的代码，编译就是浪费效率。</p>
</blockquote>
<h2 id="AOT（Ahead-of-time）"><a href="#AOT（Ahead-of-time）" class="headerlink" title="AOT（Ahead-of-time）"></a>AOT（Ahead-of-time）</h2><p>AOT，就是在程序运行之前先将代码编译成本地机器语言的程序。AOT本质上是一种静态编译，它是相对于JIT而言的，也就是说，前者是在程序运行前进行编译，而后者是在程序运行时进行编译。</p>
<blockquote>
<p>静态编译可以在运行时执行最大数量的本地代码，无需占用运行时间。但是编译方法越多，代码占用的内存也越多，大量代码可能很少甚至不会执行，编译器也无法对代码结构做优化。</p>
</blockquote>
<h1 id="Android系统上的演变"><a href="#Android系统上的演变" class="headerlink" title="Android系统上的演变"></a>Android系统上的演变</h1><p>早期Android的Dalvik虚拟机在架构上保持跟JVM高度相似，如图：</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8C%BA%E5%88%AB.jpg" alt="虚拟机区别"></p>
<ul>
<li>JNI_GetDefaultJavaVMInitArgs  –获取虚拟机的默认初始化参数</li>
<li>JNI_CreateJavaVM  – 在进程中创建虚拟机实例</li>
<li>JNI_GetCreatedJavaVMs – 获取进程中创建的虚拟机实例</li>
</ul>
<p>从最早期的解释执行到现在的混合编译，经历了多个阶段：</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/Android%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC.jpg" alt="Android系统版本"></p>
<p>尤其是在4.4之后，性能上有了较大提升。引入ART取代了Dalvik。ART的主要特征之一就是安装时对应用的AOT编译。优点是优化产生的本地代码性能更好，执行起来需要更少的电量。劣势在于安装文件所需的空间和时间。在5.0和6.0中，大的应用需要数分钟才能安装完。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/AOT%20JIT%E5%AF%B9%E6%AF%94.jpg" alt="AOT JIT对比"></p>
<p>保持dex的向下兼容<br><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8E%A5%E5%8F%A3.jpg" alt="接口不变"></p>
<p>7.0时代，ART中有一种新的、更快的解释器，通过一种新的JIT完成，但是这种JIT的信息不是持久化的。取而代之的是，代码在执行期间被分析，分析结果保存起来。然后，当设备空转和充电的时候，ART会执行针对“热代码”进行的基于分析的编译和优化。这个过程也属于AOT，可以理解为全时段的编译（All-Of-the-Time compilation）<br><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/%E6%B7%B7%E5%90%88%E8%BF%90%E8%A1%8C%E6%97%B61.png" alt="混合运行时1"></p>
<p>工作流程：</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/%E6%B7%B7%E5%90%88%E8%BF%90%E8%A1%8C%E6%97%B62.jpg" alt="混合运行时2"></p>
<blockquote>
<p>系统会收集使用代码的各种信息（用户使用习惯），存储在profiles文件夹，当收集到一定量之后，达到系统的触发条件，进行dex2oat编译成机器码直接执行。这个过程不是一次性的，而是可以进行多次的，随着收集到应用运行时的代码各种信息越多，那么代码编译的质量就越高，效率越高，能不断更新编译的机器语言，达到执行最优化。</p>
</blockquote>
<p>混合使用AOT、解释、JIT的策略，优点也很明显：</p>
<ul>
<li>应用安装时间大大缩短</li>
<li>无需要优化，系统升级更快</li>
<li>应用的内存占用更小</li>
<li>改善了性能、更低的电池消耗</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>混合模式也不是全能，达到最佳性能同样需要一个时间过程。没有万能的方案，每种模式都有其自身的优缺点，Android也是根据系统生态、硬件水平等方面的因素做出权衡。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/12/InputMethodManger导致的内存泄漏问题/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/12/InputMethodManger导致的内存泄漏问题/" itemprop="url">
                  InputMethodManger导致的内存泄漏问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-12T20:33:08+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>今天使用LeakCanary检查程序，发现很多页面都存在内存泄漏，虽然各页面的引用路径不完全相同，但最终都会指向InputMethodManager，所以考虑从InputMethodManager入手。如图：<br><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/leak/leak.png" alt="leak"><br>查看代码没有发现什么问题，于是看了一下InputMethodManager的源码,下面是获取sInstance的方法</p>
<pre><code>public static InputMethodManager getInstance() {
    synchronized (InputMethodManager.class) {
        if (sInstance == null) {
            IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);
            IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);
            sInstance = new InputMethodManager(service, Looper.getMainLooper());
        }
        return sInstance;
    }
}
</code></pre><ul>
<li>sInstance是一个全局单例，多个页面使用同一个InputMethodManager实例，也就是说sInstance的引用链指向新页面时，老的页面才能回收释放。</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>思路：</strong></p>
<p>1、定位InputMethodManager中具体的引用变量；</p>
<p>2、页面onDestroy时给其置空（使用反射）。</p>
<p>解决这个问题需要复现并结合源码进行分析，同时使用反射不免会产生一些新的bug，网上搜索看看是否有成熟的解决方案。</p>
<p>其实这是Android的一个公开bug  <a href="https://issuetracker.google.com/issues/37043700" target="_blank" rel="external">链接</a></p>
<p><strong>看如下描述</strong>：</p>
<p>InputMethodManager.mServedView keeps a reference to that last focused view, until another view get focus. This prevent the part of the view hierarchy that was detached from being garbage collected, and therefore creates a memory leak. </p>
<p>原来问题在mServedView这个变量上，它指向的就是获取焦点用于输入的view，同时这个view又持有了页面的引用。</p>
<p>贴出大神的解决方案 <a href="https://gist.github.com/pyricau/4df64341cc978a7de414" target="_blank" rel="external">链接</a>：</p>
<pre><code>public class IMMLeaksUtils {

/**
 * Fix for https://code.google.com/p/android/issues/detail?id=171190 .
 *
 * When a view that has focus gets detached, we wait for the main thread to be idle and then
 * check if the InputMethodManager is leaking a view. If yes, we tell it that the decor view got
 * focus, which is what happens if you press home and come back from recent apps. This replaces
 * the reference to the detached view with a reference to the decor view.
 *
 * Should be called from {@link Activity#onCreate(android.os.Bundle)} )}.
 */
public static InputMethodManager getInputMethodManager(Application application) {
    final InputMethodManager inputMethodManager =
            (InputMethodManager) application.getSystemService(INPUT_METHOD_SERVICE);

    if (SDK_INT &lt; KITKAT || SDK_INT &gt; 23) {
        return inputMethodManager;
    }

    final Field mServedViewField;
    final Field mHField;
    final Method finishInputLockedMethod;
    final Method focusInMethod;
    try {
        mServedViewField = InputMethodManager.class.getDeclaredField(&quot;mServedView&quot;);
        mServedViewField.setAccessible(true);
        mHField = InputMethodManager.class.getDeclaredField(&quot;mH&quot;);//lock
        mHField.setAccessible(true);
        finishInputLockedMethod = InputMethodManager.class.getDeclaredMethod(&quot;finishInputLocked&quot;);
        finishInputLockedMethod.setAccessible(true);
        focusInMethod = InputMethodManager.class.getDeclaredMethod(&quot;focusIn&quot;, View.class);
        focusInMethod.setAccessible(true);
    } catch (NoSuchMethodException | NoSuchFieldException unexpected) {
        Log.e(&quot;IMMLeaks&quot;, &quot;Unexpected reflection exception&quot;, unexpected);
        return inputMethodManager;
    }

    application.registerActivityLifecycleCallbacks(new LifecycleCallbacksAdapter() {
        @Override
        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
            ReferenceCleaner cleaner =
                    new ReferenceCleaner(inputMethodManager, mHField, mServedViewField, finishInputLockedMethod);
            View rootView = activity.getWindow().getDecorView().getRootView();
            ViewTreeObserver viewTreeObserver = rootView.getViewTreeObserver();
            viewTreeObserver.addOnGlobalFocusChangeListener(cleaner);
        }
    });

    return inputMethodManager;
}

/** Helper to avoid implementing all lifecycle callback methods. */
static class LifecycleCallbacksAdapter implements Application.ActivityLifecycleCallbacks {
    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {

    }

    @Override
    public void onActivityStarted(Activity activity) {

    }

    @Override
    public void onActivityResumed(Activity activity) {

    }

    @Override
    public void onActivityPaused(Activity activity) {

    }

    @Override
    public void onActivityStopped(Activity activity) {

    }

    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {

    }

    @Override
    public void onActivityDestroyed(Activity activity) {

    }
}

static class ReferenceCleaner implements MessageQueue.IdleHandler, View.OnAttachStateChangeListener,
        ViewTreeObserver.OnGlobalFocusChangeListener {

    private final InputMethodManager inputMethodManager;
    private final Field mHField;
    private final Field mServedViewField;
    private final Method finishInputLockedMethod;

    ReferenceCleaner(InputMethodManager inputMethodManager, Field mHField, Field mServedViewField,
            Method finishInputLockedMethod) {
        this.inputMethodManager = inputMethodManager;
        this.mHField = mHField;
        this.mServedViewField = mServedViewField;
        this.finishInputLockedMethod = finishInputLockedMethod;
    }

    @Override
    public void onGlobalFocusChanged(View oldFocus, View newFocus) {
        if (newFocus == null) {
            return;
        }
        if (oldFocus != null) {
            oldFocus.removeOnAttachStateChangeListener(this);
        }
        Looper.myQueue().removeIdleHandler(this);
        newFocus.addOnAttachStateChangeListener(this);
    }

    @Override
    public void onViewAttachedToWindow(View v) {
    }

    @Override
    public void onViewDetachedFromWindow(View v) {
        v.removeOnAttachStateChangeListener(this);
        Looper.myQueue().removeIdleHandler(this);
        Looper.myQueue().addIdleHandler(this);
    }

    @Override
    public boolean queueIdle() {
        clearInputMethodManagerLeak();
        return false;
    }

    private void clearInputMethodManagerLeak() {
        try {
            Object lock = mHField.get(inputMethodManager);
            // This is highly dependent on the InputMethodManager implementation.
            synchronized (lock) {
                View servedView = (View) mServedViewField.get(inputMethodManager);
                if (servedView != null) {

                    boolean servedViewAttached = servedView.getWindowVisibility() != View.GONE;

                    if (servedViewAttached) {
                        // The view held by the IMM was replaced without a global focus change. Let&apos;s make
                        // sure we get notified when that view detaches.

                        // Avoid double registration.
                        servedView.removeOnAttachStateChangeListener(this);
                        servedView.addOnAttachStateChangeListener(this);
                    } else {
                        // servedView is not attached. InputMethodManager is being stupid!
                        Activity activity = extractActivity(servedView.getContext());
                        if (activity == null || activity.getWindow() == null) {
                            // Unlikely case. Let&apos;s finish the input anyways.
                            finishInputLockedMethod.invoke(inputMethodManager);
                        } else {
                            View decorView = activity.getWindow().peekDecorView();
                            boolean windowAttached = decorView.getWindowVisibility() != View.GONE;
                            if (!windowAttached) {
                                finishInputLockedMethod.invoke(inputMethodManager);
                            } else {
                                decorView.requestFocusFromTouch();
                            }
                        }
                    }
                }
            }
        } catch (IllegalAccessException | InvocationTargetException unexpected) {
            Log.e(&quot;IMMLeaks&quot;, &quot;Unexpected reflection exception&quot;, unexpected);
        }
    }

    private Activity extractActivity(Context context) {
        while (true) {
            if (context instanceof Application) {
                return null;
            } else if (context instanceof Activity) {
                return (Activity) context;
            } else if (context instanceof ContextWrapper) {
                Context baseContext = ((ContextWrapper) context).getBaseContext();
                // Prevent Stack Overflow.
                if (baseContext == context) {
                    return null;
                }
                context = baseContext;
            } else {
                return null;
            }
        }
    }
}
}
</code></pre><p>上面对原代码进行了细微的调整。</p>
<p><strong>使用：</strong></p>
<ul>
<li><p>onCreate()中调用IMMLeaksUtils.getInputMethodManager方法获取InputMethodManager对象</p>
</li>
<li><p>只在有文本输入的页面调用</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/01/从Java到Kotlin/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/01/从Java到Kotlin/" itemprop="url">
                  从Java到Kotlin
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-01T19:05:06+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kotlin是什么"><a href="#Kotlin是什么" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h1><p>今年Google I/O 大会正式确立了Kotlin的地位，作为一名Android开发者，一定要紧跟Google的步伐。</p>
<p>Kotlin和Java都是基于JVM的编程语言（开源），所生成的字节码高度相似。语法上和Groovy、Javascript都很类似，非常容易上手。——IntelliJ IDEA由JetBrains开发(Android Studio基于它的插件实现) ，Kotlin也是JetBrains创造，所以他们之间存在天然的联系。</p>
<ul>
<li><strong>与Java交互性好</strong></li>
</ul>
<blockquote>
<p>Kotlin和Java的交互性很好，可以说是无缝连接。这表现在Kotlin可以自由的引用Java的代码，反之亦然。</p>
<p>Kotlin可以现有的全部的Java框架和库Java文件可以很轻松的借助IntelliJ的插件转成Kotlin</p>
</blockquote>
<ul>
<li><strong>Kotlin应用广泛</strong></li>
</ul>
<blockquote>
<p>Kotlin具有跨平台性，可以用于服务器端、Android和JavaScript </p>
<p>在Android应用开发上有着较好的支持，存在Dagger，RxKotlin,Anko等等工具库。目前一些大厂以及开源项目已经使用Kotlin，Java转Kotlin在不久的将来就会全面展开。</p>
</blockquote>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><p><strong>1、语法上(不讲具体的语法，特性)</strong></p>
<pre><code>//variables and constants
var currentVersionCode = 1   //变量当前的版本号，类型Int可以根据值推断出来
var currentVersionName : String = &quot;1.0&quot; //显式标明类型
val APPNAME = &quot;droidyue.com&quot; //常量APPNAME 类型(String)可以根据值推断出来

//methods
fun main(args: Array&lt;String&gt;) {
    println(args)
}

// class
class MainActivity : AppCompatActivity() {

}
</code></pre><ul>
<li>Kotlin支持智能类型转换。</li>
<li>另外用var表示变量，val表示常量更加的简洁</li>
<li>方法也很简单（使用fun缩写标识方法）</li>
<li>类的继承和实现很简单，使用:即可</li>
<li>Kotlin每个句子都不需要加分号;</li>
</ul>
<p><strong>2、简化代码，代码量大大减少。</strong></p>
<p>Java</p>
<pre><code>public class User {
    private String name;
    private String id;

    public User(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}
</code></pre><p>Kotlin </p>
<pre><code>data class User(var name: String, var id: String)
</code></pre><p> Kotlin 就会创建出一个完整的数据类，并自动生成相应的 equals、hashcode、toString 方法</p>
<p><strong>3、便于扩展，现有类的基础上，添加一些属性或者方法，无需继承。</strong></p>
<p>Java</p>
<pre><code>Button button = findviewbyid(R.id.button)
button.setOnClickListener(new View.OnClickListener() {
    @Override public void onClick(View v) {
        Toast.makeText(this,&quot;hello java&quot;,Toast.LENGTH_SHORT);
    }
});
</code></pre><p>Kotlin</p>
<pre><code>//支持默认参数值，减少方法重载
fun Context.toast(message: String, duration:Int = Toast.LENGTH_LONG) {
    Toast.makeText(this, message, duration).show()
}

button.setOnClickListener {toast(&quot;hello kotlin&quot;)}
</code></pre><p><strong>4、安全性</strong></p>
<p>Java</p>
<pre><code>public void test(String string) {
    if (string != null) {
        char[] chars = string.toCharArray();
        if (chars.length &gt; 10) {
            System.out.println(((Character)chars[10]).hashCode());
        }
    }
}
</code></pre><p>Kotlin  </p>
<pre><code>fun testNullSafeOperator(string: String?) {
    System.out.println(string?.toCharArray()?.getOrNull(10)?.hashCode())
}
</code></pre><p>Java中不得不写很多防御性的代码，防止出现NullPointerException，Kotlin使用空安全符？来明确对象是否为空，否则编译无法通过。</p>
<h1 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h1><p>Android Studio在3.0版本中直接集成了Kotlin插件，在3.0之下还需手动安装：</p>
<p><strong>1、在Setting里找到Plugin选项，搜索Kotlin插件。</strong></p>
<ul>
<li>Kotlin：基础插件，对Kotlin的语法支持</li>
<li><p>Kotlin Android Extensions：可以自动从XML中注入View到activity中，作为属性直接使用，省去了findViewById()和convert view的过程。</p>
<pre><code>//导入指定布局文件中所有控件属性
import kotlinx.android.synthetic.main.＜布局＞.*
</code></pre><p>  ButterKnife可以扔到垃圾桶了。但存在一个问题，对于历史XML布局文件，ViewID的命名方式可能在Java代码中并不友好。解决办法：</p>
<blockquote>
<p>1、给布局文件中的viewID rename</p>
<p>2、扩展Content类，自定义变量名转换映射方法</p>
<p>3、继续使用findViewById方式。</p>
</blockquote>
</li>
</ul>
<p><strong>2、在模块的gradle下加入如下代码：</strong></p>
<pre><code>apply plugin: &apos;kotlin-android&apos;
apply plugin: &apos;kotlin-android-extensions&apos;
</code></pre><p>   <strong>然后在project的gradle下加入：</strong></p>
<pre><code>classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$yourversion&quot;
</code></pre><p><strong>3、编写Kotlin  or Java代码转换</strong></p>
<p><strong>4、构建和发布用于 Android 的 Kotlin 应用程序</strong></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>1、官方3.0正式版未发布，可能有坑</strong></p>
<p><strong>2、是否带来效率的提高?</strong></p>
<blockquote>
<p>在生成环境中，稳定高于一切。追求新技术，一方面会给团队带来开发和维护上的学习成本，另一方面也要承担未来某些情况下因为对新技术不熟悉而产生未知问题的风险。</p>
<p>在后面的项目中，部分小模块可以选择性使用。Kotlin的优势会慢慢展现出来的，但是需要一个较为漫长的过渡期。</p>
</blockquote>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p>官方网站<br>链接：<a href="http://kotlinlang.org/" target="_blank" rel="external">http://kotlinlang.org/</a></p>
<p>在线代码环境<br>链接：<a href="https://try.kotlinlang.org/" target="_blank" rel="external">https://try.kotlinlang.org/</a> </p>
<p>官方GitHub<br>链接：<a href="https://github.com/JetBrains/kotlin" target="_blank" rel="external">https://github.com/JetBrains/kotlin</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/打造一个通用Adapter/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/28/打造一个通用Adapter/" itemprop="url">
                  打造一个通用Adapter
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T21:33:54+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目通知模块涉及到的通知类型多达三四十种，并且消息列表分散在多个页面。本文使用RecycleView展示多种布局类型，考虑到通知消息格式具有一定的相似性，所以把它做成一个通用Adapter，便于后期的扩展和维护。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Android系统在v7包中提供了一种新的组件RecycleView，通过LayoutManager来实现过去常常使用的ListView和GridView，使用过程中重写RecycleViewAdapter的三个方法：</p>
<blockquote>
<p>1、首先在getItemViewType方法中返回固定的类型标识viewType。ItemView的type类型，由服务端返回的数据Model决定。</p>
<p>2、然后在onCreateViewHolder中根据viewType参数，也就是getItemViewType的返回值来判断需要创建的ViewHolder类型。</p>
<p>3、最后在onBindViewHolder方法中对ViewHolder的具体类型进行判断，分别为不同类型的ViewHolder进行绑定数据与逻辑处理。</p>
</blockquote>
<p>所以Adapter的实现代码如下：</p>
<pre><code>    @Override
public int getItemViewType(int position) {
    if (mNoticesMessageDTOs != null &amp;&amp; position &lt; mNoticesMessageDTOs.size()) {
        return mNoticesMessageDTOs.get(position).getEventType();
    }
}

@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    RecyclerView.ViewHolder viewHolder = null;
    switch (viewType) {
        ......
        case Constants.EventType.FOLDER_CREATE:
        case Constants.EventType.FOLDER_RESTORE:
        case Constants.EventType.FOLDER_DELETE:
            viewHolder = new NoticeCardVHolder(parent, mViewComponent);
            break;
        case Constants.EventType.DISCUSS_NEW_TOPIC:
        case Constants.EventType.DISCUSS_NEW_COMMIT:
        case Constants.EventType.DISCUSS_REPLY_COMMIT:
        case Constants.EventType.DISCUSS_AT_YOU:
            viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
            break;

    }
    return viewHolder;
}

@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
    if (holder instanceof NoticeCardVHolder) {
        ((NoticeCardVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectVHolder) {
        ((NoticeProjectVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectAnounceVHolder) {
        ((NoticeProjectAnounceVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeLabelVHolder) {
        ((NoticeLabelVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectApproveVHolder) {
        ((NoticeProjectApproveVHolder) holder).render(mNoticesMessageDTOs.get(position));
    }
}

@Override
public int getItemCount() {
    return mNoticesMessageDTOs.size();
}
</code></pre><p>很明显看出，这种实现方式存在如下缺陷：</p>
<p>1、类型检查与转换方式低效。由于在onCreateViewHolder中根据不同类型创建了不同的ViewHolder，所以onBindViewHolder方法需要针对不同类型的ViewHolder进行数据绑定与逻辑处理。</p>
<p>2、不利于扩展和维护。数据源是从服务端获取，当需求发生变化，比如新增其他通知类型，或者Model数据结构发生变化时，需要重写以上三个方法。随着类型的逐渐增多，Adapter会越来越臃肿，变得难以维护。</p>
<p>3、代码的重复实现。每种类型的ViewHolder单独实现事件点击、设置已读样式等。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>针对前文所提到的三点问题，从getItemViewType、onCreateViewHolder、onBindViewHolder这三个方法入手，提出以下解决思路：</p>
<p><strong>1、实现BaseViewHolder。</strong>从不同ViewHolder中抽象出相似的功能，比如点击跳转，设置已读样式，头像的显示规则等，避免重复实现。在继承RecyclerView.ViewHolder的基础上派生出BaseViewHolder，所有ViewHolder必须继承BaseViewHolder，并在此基础上扩展。</p>
<pre><code>abstract public class BaseVHolder extends RecyclerView.ViewHolder {

    public BaseVHolder(View itemView, ViewComponent component) {
        super(itemView);
        if (component != null) {
            component.inject(this);
        }
    }

    public void render(NoticesMessageDTO noticesMessageDTO) {

    }

    protected void modifyLayout() {
      ......
    }

    public CharSequence renderSpan(String text, String color, boolean isBold, boolean isDelete) {
       ......
    }

    public void setUserImage(SimpleDraweeView mUserAvator, NoticesMessageDTO.ContentObj contentObj) {
        ......
    }

    public void parseDeleteLine(SpannableStringBuilder operateStr) {
        ......
    }

    //页面路由统一处理跳转事件
    public void setOnNoticesItemClickListener(final NoticesMessageDTO noticesMessageDTO) {
        ......
    }

    //设置item为已读样式
    protected void setItemReaded() {
            ......
    }

}
</code></pre><p><strong>2、合并ViewHolder。</strong>将所有通知类型（服务端控制）按视觉样式分为五个大类，并创建五种不同的itemView，然后根据viewType实现五种ViewHolder。如下是卡片相关通知类型。</p>
<pre><code>public class NoticeCardVHolder extends BaseVHolder {
    @BindView(R.id.tv_user_name)
    TextView mUserName;
    @BindView(R.id.project_name)
    TextView mProjectName;
    @BindView(operate)
    TextView mOperate;
    @BindView(R.id.user_avator)
    SimpleDraweeView mUserAvator;
    @BindView(R.id.date)
    TextView mDate;

    public NoticeCardVHolder(ViewGroup parent, ViewComponent component) {
        super(LayoutInflater.from(parent.getContext()).inflate(R.layout.notice_card_view_holder, parent, false),
                component);
        ButterKnife.bind(this, itemView);
    }

    public void render(NoticesMessageDTO noticesMessageDTO) {
        ......
    }

    //文案拼接
    private void renderOperateView(NoticesMessageDTO.ContentObj contentObj, int readYn) {
        ......
    }

        protected void setItemReaded() {
        ......
    }
}
</code></pre><p><strong>3、BaseViewHolder作为onCreateViewHolder方法的返回值类型。</strong><br>BaseViewHolder作为ViewHolder的基类，可避免在onBindViewHolder中对ViewHolder进行类型检查与类型转换，简化了onBindViewHolder方法中的数据绑定与逻辑处理。</p>
<p>按以上实现思路，getItemViewType 、onCreateViewHolder和onBindViewHolder方法的代码将变得相对简单。如下</p>
<pre><code>@Override
public int getItemViewType(int position) {
    if (mNoticesMessageDTOs != null &amp;&amp; position &lt; mNoticesMessageDTOs.size()) {
        return mNoticesMessageDTOs.get(position).getEventType();
    }
}

public BaseVHolder onCreateViewHolder(ViewGroup parent, int viewType) { 
    BaseVHolder viewHolder = null;
    switch (viewType) {
            ......    
        case Constants.EventType.CARD_DELTE:
        case Constants.EventType.CARD_RESTORE:
        case Constants.EventType.CARD_MOVE:
        case Constants.EventType.CARD_RENAME:
            viewHolder = new NoticeCardVHolder(parent, mViewComponent);
            break;
        case Constants.EventType.DISCUSS_NEW_TOPIC:
        case Constants.EventType.DISCUSS_NEW_COMMIT:
        case Constants.EventType.DISCUSS_REPLY_COMMIT:
        case Constants.EventType.DISCUSS_AT_YOU:
            viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
            break;
        default:
            viewHolder = null;
            break;
    }
    return viewHolder;
}

@Override
public void onBindViewHolder(BaseVHolder holder, int position) {
    holder.render(mNoticesMessageDTOs.get(position));
} 
</code></pre><p>在onBindViewHolder中不需要对ViewHolder进行任何操作，数据的绑定和逻辑处理都交给对应的ViewHolder来处理，因此每个ViewHolder可根据实际情况实现render方法。这样所有的业务逻辑全部放在ViewHolder中，如果新增一种类型只需实现对应的ViewHolder，然后在onCreateViewHolder方法中创建ViewHolder类型即可，这样Adapter会便于扩展和维护。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>前面实现的Adapter只能处理通知相关类型，算不上真正的通用。如果应用场景发生变化，比如项目列表、文件记录或搜索结果列表等，此时所绑定的数据Model不再是通知类型，Adapter将无法适应这些情况。因此做了如下改造：</p>
<p><strong>1、定义通用的viewType类型。</strong></p>
<pre><code>/** 定义不同vholder类型 **/
public interface VHolderType {
    /** 通知相关 */
    int NoticeProjectAnounce = 101;
    int NoticeProjectApprove = 102;
    int NoticeProject = 103;
    int NoticeCard = 104;
    int NoticeLabel = 105;
    /** 搜索相关 **/
    int SearchCardHead = 201;
    int SearchCard = 202;
    int SearchFile = 203;
    int SearchFolder = 204;
    /** 项目相关 **/
    int ShowProject = 301;
}
</code></pre><p><strong>2、数据Model中增加type标识。</strong>前面介绍的viewType是由服务端控制，这里为兼容不同的数据Model，需要在本地统一配置管理，然后根据Model获得自定义viewType。</p>
<ul>
<li><p><strong>定义抽象接口</strong></p>
<pre><code>public interface TypeFactory {
    int type(NoticesMessageDTO noticesMessageDTO);
    int type(SearchResourceDTO searchResourceDTO);
    int type(ProjectInfoDTO projectInfoDTO);
}

//列表相关Model需实现该接口
public interface ViewModel {
    int type(TypeFactory typeFactory);
}
</code></pre></li>
</ul>
<ul>
<li><strong>实现ViewModel接口。</strong>不同类型的Model以List\<viewmodel\> 的形式放在列表中。</viewmodel\></li>
</ul>
<pre><code>public class SearchResourceDTO implements MessagesAdapter.ViewModel{
    ......
    @Override
    public int type(MessagesAdapter.TypeFactory typeFactory) {
        return  typeFactory.type(this);
    }
}

public class NoticesMessageDTO implements MessagesAdapter.ViewModel{
    ......
    @Override
    public int type(MessagesAdapter.TypeFactory typeFactory) {
        return typeFactory.type(this);
    }
}
</code></pre><p><strong>3、配置TypeFactory，将Model数据转化为通用viewType。</strong></p>
<pre><code>public static class TypeFactoryForList implements TypeFactory {
    @Override
    public int type(NoticesMessageDTO noticesMessageDTO) {
        int viewType = 0;
        if (noticesMessageDTO != null) {
            switch (noticesMessageDTO.getEventType()) {
                   ......

                case Constants.EventType.PROJECT_MODIFY_NOTICE: // 公告
                    viewType = Constants.VHolderType.NoticeProjectAnounce;
                    break;
                case Constants.EventType.PROJECT_MODIFY_NAME: // 项目信息更新1003
                    viewType = Constants.VHolderType.NoticeProject;
                    break;
                Constants.EventType.CARD_FOLLOW_CANCEL:
                case Constants.EventType.CARD_ADD_FOLLOW:
                case Constants.EventType.CARD_REMOVE_FOLLOW:
                case Constants.EventType.FILE_UPLOAD: // 文件
                case Constants.EventType.FILE_UPDATE:
                case Constants.EventType.FILE_DELETE:
                case Constants.EventType.FILE_RESTORE:
                Constants.EventType.FOLDER_UPLOAD: // 文件夹
                case Constants.EventType.FOLDER_CREATE:
                case Constants.EventType.FOLDER_RESTORE:
                case Constants.EventType.FOLDER_DELETE:
                    viewType = Constants.VHolderType.NoticeCard;
                    break;
                //讨论标注相关
                case Constants.EventType.DISCUSS_NEW_TOPIC:
                case Constants.EventType.DISCUSS_NEW_COMMIT:
                case Constants.EventType.DISCUSS_REPLY_COMMIT:
                case Constants.EventType.DISCUSS_AT_YOU:
                    viewType = Constants.VHolderType.NoticeLabel;
                    break;
            }
        }
        return viewType;
    }

    public int type(SearchResourceDTO searchResourceDTO) {
        int viewType = 0;
        if (searchResourceDTO != null) {
            switch (searchResourceDTO.getResType()) {
                case Constants.SearchResultType.RES_CARD_HEAD:
                    viewType = Constants.VHolderType.SearchCardHead;
                    break;
                case Constants.SearchResultType.RES_CARD:
                    viewType = Constants.VHolderType.SearchCard;
                    break;
                case Constants.SearchResultType.RES_FILE:
                    viewType = Constants.VHolderType.SearchFile;
                    break;
                case Constants.SearchResultType.RES_FOLDER:
                    viewType = Constants.VHolderType.SearchFolder;
            }
        }
        return viewType;
    }

    public int type(ProjectInfoDTO projectInfoDTO) {
        return Constants.VHolderType.ShowProject;
    }
}
</code></pre><p>将类型判断抽取到TypeFactoryForList中，减轻了onCreateViewHolder方法的代码量，同时便于对各种类型进行统一管理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过改进后的Adapter代码如下：</p>
<pre><code>public class MessagesAdapter extends RecyclerView.Adapter&lt;BaseVHolder&gt; {
    private List&lt;ViewModel&gt; mMessageDTOs;

    private ViewComponent mViewComponent;

    public MessagesAdapter(ViewComponent component) {
        mViewComponent = component;
        mMessageDTOs = new ArrayList&lt;ViewModel&gt;();
    }

    @Override
    public int getItemViewType(int position) {
        return mMessageDTOs.get(position).type(new TypeFactoryForList());
    }

    @Override
    public BaseVHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        BaseVHolder viewHolder = null;
        switch (viewType) {
            ......
            case Constants.VHolderType.NoticeProjectAnounce: 
                viewHolder = new NoticeProjectAnounceVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeProjectApprove:
                viewHolder = new NoticeProjectApproveVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeProject:
                viewHolder = new NoticeProjectVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeCard:
                viewHolder = new NoticeCardVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeLabel:
                viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
                break;
        }
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(BaseVHolder holder, int position) {
        holder.render(mMessageDTOs.get(position));
    }
     ......
}
</code></pre><p>将原本应该在Adapter中实现的代码抽离出来，让Adapter更加简洁，更多的逻辑放在ViewHolder和TypeFactory中，数据列表的Item更加独立，甚至可以让不同Model数据混合显示。具有较强的通用性，<br>能够实现列表页面的快速复制。<br>但是还存在一些不足，比如BaseViewHolder中的render方法可能还需要扩展，才能更好的满足多Model情况下的数据绑定与逻辑处理，大家可以根据实际情况进行修改。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" target="_blank" rel="external">https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html</a></p>
<p><a href="http://www.jianshu.com/p/c6a44e18badb" target="_blank" rel="external">http://www.jianshu.com/p/c6a44e18badb</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/16/代码规范检查/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/16/代码规范检查/" itemprop="url">
                  代码规范检查
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-16T19:03:56+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了保证团队内部代码风格的统一，提升代码的质量，更好的遵循标准的编写规范。必须定义一个统一的规范，在执行上前期主要由团队的老司机进行codereview，并对review出来的问题进行总结和回顾，避免后期犯类似的错误。但是这样会加大老司机的工作量，降低整个团队的工作效率，如果项目周期比较赶可能会放松对代码的要求。因此，有必要引入自动化工具来帮助我们保证代码的质量，这里主要采用两种办法：</p>
<ul>
<li><p><strong>coding阶段</strong>：为IDE配置统一的格式化模板，在完成开发后手动进行format。具体配置方式参见<a href="http://note.youdao.com/groupshare/?token=A0EFFF04E19246089EAFACD7A818FEF0&amp;gid=30539562" target="_blank" rel="external">Android端Code Style统一规范</a></p>
</li>
<li><p><strong>build阶段</strong>：使用checkstyle工具检查代码，注释、命名规范、方法长度、空格缩进等不再需要手工检查，由于标准的check过于严格，可以根据实际情况取消部分检查规则。对于不符合规范的代码，警告或者错误提示。</p>
</li>
</ul>
<h1 id="Checkstyle配置"><a href="#Checkstyle配置" class="headerlink" title="Checkstyle配置"></a>Checkstyle配置</h1><p>具体的配置步骤：</p>
<p>1、将自定义的checkstyle.xml文件放在项目/setting目录下.</p>
<p>2、添加checkstyle任务，并配置检查项目。</p>
<pre><code>allprojects{
   repositories{ 
         jcenter()
 }
 task checkstyle(type: Checkstyle) {
       showViolations = true
       configFile file(&quot;../settings/checkstyle.xml&quot;)
       source &apos;src/main/java&apos;//检查Java代码
       include &apos;**/*.java&apos;  //不检查
       exclude &apos;**/gen/**&apos;
       exclude &apos;**/R.java&apos;
       exclude &apos;**/BuildConfig.java&apos;

       // empty classpath
       classpath = files()
       ignoreFailures true     // 忽略检查失败的情况，避免gradle命令执行中止
   }
}
</code></pre><p>3、在module的build.gradle中添加checkstyle插件，并声明checkstyle任务的执行条件。</p>
<pre><code>apply plugin: &apos;checkstyle&apos;

preBuild.dependsOn(&apos;checkstyle&apos;)
assemble.dependsOn(&apos;lint&apos;)
check.dependsOn(&apos;checkstyle&apos;)
</code></pre><p>4、在终端中执行如下命令，可在/app/build/reports中看到生成的警示报告文件。</p>
<pre><code>./gradlew checkstyle 
</code></pre><h1 id="自定义xml配置文件"><a href="#自定义xml配置文件" class="headerlink" title="自定义xml配置文件"></a>自定义xml配置文件</h1><p>IDE的Code Style Format包括如下几个部分：</p>
<ul>
<li>Tabs and Indents</li>
<li>Spaces</li>
<li>Wrapping and braces</li>
<li>Blank lines</li>
<li>JavaDoc</li>
<li>Arrangement</li>
<li>Imports</li>
<li>Code Generation</li>
</ul>
<p>可以直接在IntelliJ IDEA中勾选设置，然后导出配置文件，共享给团队成员。但它只能对代码的格式进行自动调整，无法检查代码的问题和错误。Checkstyle插件是在format的基础上，对代码的格式和语法进行检查和分析，包括下面几大类型：</p>
<ul>
<li>Javadoc Comments </li>
<li>Naming Conventions</li>
<li>Imports</li>
<li>Size Violations</li>
<li>Whitespace</li>
<li>ModifierOrder</li>
<li>Block Checks</li>
<li>Coding</li>
<li>Class Design</li>
<li>Duplicate Code</li>
<li>Miscellaneous</li>
</ul>
<p>根据项目实际情况，主要对Javadoc注释、命名规范、import语句、代码块、缩进和空行以及风格、类设计、重复代码等分析规则进行配置。<br>具体配置文件如下<a href="https://github.com/checkstyle/checkstyle/blob/master/config/checkstyle_checks.xml" target="_blank" rel="external">checkstyle.xml</a></p>
<blockquote>
<p>这里参照了官方提供的配置文件<a href="https://github.com/checkstyle/checkstyle/blob/master/config/checkstyle_checks.xml" target="_blank" rel="external">checkstyle_checks.xml</a>，并加以详细的注释，可根据实际需求添加或移除module。</p>
</blockquote>
<h1 id="自定义文件说明"><a href="#自定义文件说明" class="headerlink" title="自定义文件说明"></a>自定义文件说明</h1><p>Checkstyle配置文件通过指定modules应用到java文件。modules是树状结构，以一个名为Checker的module作为root节点，一般的checker都会包括TreeWalker子module。</p>
<blockquote>
<p>xml配置文件中通过module的name属性来区分module，module的Properties可以控制如何去执行这个module，每个property都有一个默认值，所有的check都有一个severity属性，用它来指定check的level。TreeWalker为每个java文件创建一个语法树，在节点之间调用submodules的Checks。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/28/实现多样式富文本/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/28/实现多样式富文本/" itemprop="url">
                  如何实现多样式富文本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T12:55:55+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目中需要使用富文本来显示消息通知，由于消息的类型多达几十种，且这些不同类型消息显示的文案由服务端控制，这里文案需要使用富文本来显示不同颜色、大小、字体的文字，所幸是textView支持富文本显示。具体实现方法有两种。</p>
<h2 id="使用HTML-标记设置样式"><a href="#使用HTML-标记设置样式" class="headerlink" title="使用HTML 标记设置样式"></a>使用HTML 标记设置样式</h2><p>将待显示字符串添加到strings文件中。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;string name=<span class="string">"welcome"</span>&gt;Welcome to&lt;b&gt;Android&lt;/b&gt;!&lt;/string&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>支持的 HTML 标签包括：</p>
<pre><code class="bash">
&lt;a href=<span class="string">"..."</span>&gt;创建超文本链接

&lt;b&gt;黑体字

&lt;big&gt;字体加大

&lt;blockquote&gt;从两边缩进文本

&lt;br&gt;换行插入换行符

&lt;cite&gt;引用，通常是斜体

&lt;dfn&gt;述语定义

&lt;div align=<span class="string">"..."</span>&gt;用来排版大块HTML段落,也用于格式化表

&lt;em&gt;强调文本(通常是斜体加黑体)

&lt;font size=<span class="string">"..."</span> color=<span class="string">"..."</span>face=<span class="string">"..."</span>&gt;设置字体大小从1到7，颜色使用名字或RGB的十六进制值

&lt;h1&gt;至&lt;h6&gt;标题

&lt;i&gt;斜体字

&lt;img src=<span class="string">"..."</span>&gt;图片

&lt;p&gt;创建一个段落

&lt;small&gt;字体缩小

&lt;strike&gt;加删除线

&lt;strong&gt;加重文本(通常是斜体加黑体)

&lt;sub&gt;下标字

&lt;sup&gt;上标字

&lt;tt&gt;打字机风格的字体

&lt;u&gt;下划线
</code></pre>
<p>如果将带样式文本资源作为格式字符串。 正常情况下是行不通的，因为 String.format(String,Object…) 方法会去除字符串中的所有样式信息。要解决这个问题只能编写带转义实体的 HTML 标签，在完成格式设置后，这些实体可通过fromHtml(String) 恢复。 例如：</p>
<p><strong>1.将您带样式的文本资源存储为HTML 转义字符串：</strong></p>
<pre><code class="bash">&lt;resources&gt;
  &lt;string name=<span class="string">"welcome_messages"</span>&gt;Hello, %1<span class="variable">$s</span>! You have &amp;lt;b&gt;%2<span class="variable">$d</span> newmessages&amp;lt;/b&gt;.&lt;/string&gt;
&lt;/resources&gt;
</code></pre>
<p>在这个带格式的字符串中，添加了 \<b> 元素。请注意，开括号使用 \&lt; 表示法进行了 HTML 转义。</b></p>
<p><strong>2.然后照常设置字符串格式，但还要调用 <a href="https://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String" target="_blank" rel="external">fromHtml(String)</a>) 以将HTML 文本转换成带样式文本：</strong></p>
<pre><code class="bash">Resources res = getResources();
String text =String.format(res.getString(R.string.welcome_messages), username, mailCount);
CharSequence styledText = Html.fromHtml(text);
</code></pre>
<p>由于 fromHtml(String) 方法将设置所有 HTML 实体的格式，因此务必要使用 htmlEncode(String) 对您用于带格式文本的字符串中任何可能的 HTML 字符进行转义。 例如，如果您向 String.format() 传递的字符串参数可能包含“&lt;”或“&amp;”之类的字符，则必须在设置格式前进行转义，这样在通过 fromHtml(String) 传递带格式字符串时，字符就能以原始形式显示出来。 例如：</p>
<pre><code class="bash">String escapedUsername = TextUtil.htmlEncode(username);
Resources res =getResources();
String text =String.format(res.getString(R.string.welcome_messages), escapedUsername, mailCount);
CharSequence styledText = Html.fromHtml(text);
</code></pre>
<h2 id="使用Spannable-设置样式"><a href="#使用Spannable-设置样式" class="headerlink" title="使用Spannable 设置样式"></a>使用Spannable 设置样式</h2><p><a href="https://developer.android.com/reference/android/text/Spannable.html" target="_blank" rel="external">Spannable</a>可以对颜色和字体粗细等属性进行样式设置。 首先使用 SpannableStringBuilder 构造文本内容，然后为文本设置 android.text.style 包中定义的样式，常见的样式有StrikethroughSpan、StyleSpan、ForegroundColorSpan等。例如，为某段文字内容加上带颜色和删除线的粗体样式。</p>
<pre><code class="bash">public CharSequence renderSpan(Stringtext, String color, boolean isBold, boolean isDelete) {

    <span class="keyword">if</span>(TextUtils.isEmpty(color)) {
        color =<span class="string">"#272934"</span>;//默认值
    }
    <span class="keyword">if</span>(TextUtils.isEmpty(text)) {
        <span class="built_in">return</span> null;
    }
   SpannableStringBuilder span = new SpannableStringBuilder();
   span.append(text);
    <span class="keyword">if</span>(isDelete) {
        StrikethroughSpanstrikethroughSpan = new StrikethroughSpan();
        span.setSpan(strikethroughSpan,0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    <span class="keyword">if</span> (isBold){
        StyleSpanboldStyle = new StyleSpan(Typeface.BOLD);
        span.setSpan(boldStyle,0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    span.setSpan(newForegroundColorSpan(Color.parseColor(color)), 0,text.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    returnspan;

}
</code></pre>
<p>最后，项目中用到了格式化字符串，所以只能采取第一种方式来避免样式信息被清除。这里遇到一个非常奇葩的坑， fromHtml(String)无法正常显示带\<strike>标签的格式。解决办法是结合使用spannable，如下：</strike></p>
<pre><code>public CharSequence renderSpan(String text,String color, boolean isBold, boolean isDelete) {
   if(TextUtils.isEmpty(color)) {
       color =&quot;#272934&quot;;
   }
   if(TextUtils.isEmpty(text)) {
       returnspan;
   }
   SpannableStringBuilder span = new SpannableStringBuilder();
   span.append(text);
   if(isDelete) {
      span.insert(0, &quot;&lt;strike&gt;&quot;);
      span.append(&quot;&lt;/strike&gt;&quot;);
   }
   if (isBold){
      span.insert(0, &quot;&lt;b&gt;&quot;);
      span.append(&quot;&lt;/b&gt;&quot;);
   }
  //span.insert(0, &quot;&lt;font color=\&quot;&quot; + color +&quot;\&quot;&gt;&quot;);
  //span.append(&quot;&lt;/font&gt;&quot;);
   return span;
}




   Resources res = getResources();
   String text = String.format(res.getString(R.string.welcome_messages),renderSpan(escapedUsername ,&quot;&quot;,true,true));    
   SpannableStringBuilder operateStr =new  SpannableStringBuilder(text);
   Object[]spans = operateStr.getSpans(0, operateStr.length(), Object.class);
   if (spans.length &gt; 0) {
       for(Object object : spans) {
           intstart = operateStr.getSpanStart(object);
           intend = operateStr.getSpanEnd(object);
           StrikethroughSpan strikethroughSpan = new StrikethroughSpan();
           operateStr.setSpan(strikethroughSpan, start, end,Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
           break;
       }

   }
</code></pre><p>这里通过其他span对象来确定样式字符串的位置，然后采用第二种方式进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/22/Android图片缓存分析与优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/22/Android图片缓存分析与优化/" itemprop="url">
                  Android图片缓存分析与优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-22T20:14:23+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近分析线上日志，发现存在一定量的OutOfMemoryError。由于Android系统对堆内存大小作了限制，不同的设备上这个阈值也会不同，当已分配内存加新分配内存大于堆内存就会导致OOM。虽然Android机型的配置在不断升级，但还是存在着几年前的旧机型，它们的特点是内存小，尤其在涉及大图片加载时很容易出现OOM。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了避免OOM，程序应该增加可用内存，并及时回收不再使用的对象，降低内存占用。可以从以下几个方面去考虑：</p>
<p><strong>1、对图片进行处理，如图片裁剪和压缩。</strong></p>
<p>使用缩略图来提高加载速度和降低内存占用。根据控件大小对图片进行裁剪，减少不必要内存浪费。我们的项目中使用了NOS提供的图片处理服务，它提供了非常强大的云处理功能，在开发过程中根据实际需要生成请求链接，获取不同尺寸的图片，实现图片裁剪。同时使用BitmapFactory.Options属性，通过设置采样率, 减少Bitmap的像素。</p>
<p><strong>2、内存引用上做一些处理，常用的有软引用。</strong></p>
<p>使用软引用的对象在内存足够时，垃圾回收器不会回收它；当内存空间不足时，为满足程序运行的需求，会回收这些对象，避免出现OOM导致的程序崩溃。因此只要对象没有被回收都能被程序使用。过去很多应用都大量使用软引用进行图片缓存，通过GC自动回收图片所占内存。下图是谷歌对图片缓存的说明：        </p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%8A%E7%AB%AF.jpg" alt="软引用"></p>
<p>从上图可以看出，从Android 2. 3开始，垃圾回收器会更倾向于回收持有软引用或弱引用的对象，这让软引用和弱引用变得不再可靠。另外，在Android 3.0中，图片的数据会存储在本地的内存当中，因而无法用一种可预见的方式将其释放，这就有潜在的风险造成应用程序的内存溢出并崩溃，所以在开发过程中要谨慎使用。</p>
<p><strong>3、缓存机制。</strong></p>
<p>缓存不仅可以减少流量的浪费还能防止加载过多的图片，项目中使用了比较主流的内存、文件和网络三级缓存。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.jpg" alt="三级缓存"></p>
<p>通过URL向网络请求图片时，先从内存中查找，如果内存中没有，再从缓存文件中查找，如果缓存文件中也没有，再向网络发Http请求下载图片，然后再依次缓存在内存和文件中。</p>
<p>在项目中使用了强引用（LRUCache）与软引用相结合的方式进行内存缓存。系统不会回收强引用的对象，为了防止OOM，需要为LRUCache设置适当的大小，并及时回收内存。因为堆空间又被分为年轻代、老年代和永久代，新分配的对象会先放在年轻代中，当停留一段时间后，这个对象会被移动到老年代，最后再移动到永久代中。系统的每一个内存区域都采用不同的策略进行GC操作，年轻代的对象更容易被销毁，而且GC操作的速度比老年代的速度要快，时间更短。</p>
<p>同时Android系统并不会对空闲内存区域做碎片整理，只有在内存不足时触发GC进行回收，从而造成空间上的浪费。因此，程序应该在适当的时候主动回收不再使用的图片，减少被动回收导致的内存溢出风险。</p>
<p><strong>4、自定义堆内存大小，如使用largeHeap。</strong></p>
<p>在Manifest.xml中的Application节点下加入android:largeHeap=”true”，系统便能为应用程序分配更多的内存空间，但是这种方式不能根本解决问题，不合理的使用内存同样会造成OOM，只是延缓其发生。对于一些内存占用比较大的图片、视频类应用，最好在开发测试过后再加上该属性。</p>
<p><strong>5、使用第三方开源图片框架</strong>，比如Picasso、Glide、Fresco等，它们在图片异步加载、缓存、内存管理和优化等方面已经做了很好的处理。</p>
<h1 id="基于LRUCache的缓存"><a href="#基于LRUCache的缓存" class="headerlink" title="基于LRUCache的缓存"></a>基于LRUCache的缓存</h1><p>前面介绍了几种避免OOM的方式，在实际项目中需要结合使用。本文主要介绍内存缓存的实现，包括强引用缓存和软引用缓存两个部分。强引用缓存采用LRUCache实现,它是Android系统为开发人员提供的缓存工具类，实际上是将强引用的对象存储在LinkedHashMap中，初始化时会设置缓存空间大小，当缓存数据达到预设值时会采用最近最少使用算法进行淘汰。另外，软引用缓存同样使用LinkedHashMap作为存储结构，将从LRUCache淘汰的数据扔到软引用缓存中，之前的做法是对软引用对象不做任何处理，等待垃圾回收器自动回收。大量使用软引用的弊端前面也有介绍，本文对此做了部分改进，有限的使用软引用对象，当软引用缓存空间不足时，同样按照LRU规则淘汰并主动回收内存空间。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/lru%E7%BC%93%E5%AD%98.jpg" alt="LRU缓存">      </p>
<p>首先，通过图片的URL从网络下载图片，将图片先缓存到内存缓存中，缓存到强引用也就是LruCache中。如果LruCache空间不足，就会将较早存储的图片对象淘汰到软引用缓存中，然后将图片缓存到文件中。在读取图片时，先读取内存缓存，判断LruCache是否存在图片，如果存在，则直接读取，如果LruCache中不存在，则判断软引用中是否存在，如果软引用中存在，则将软引用中的图片添加到LruCache并且删除软引用中的数据，如果软引用中不存在，则从文件或网络读取。</p>
<h1 id="代码分析与实现"><a href="#代码分析与实现" class="headerlink" title="代码分析与实现"></a>代码分析与实现</h1><p>首先，通过继承LRUCache类实现BitmapLRUCache，里面的键值对分别是URL和对应图片的Drawable对象。</p>
<pre><code>class BitmapLRUCache extends LruCache&lt;String, Drawable&gt;
</code></pre><p>然后在构造方法中初始化软引用缓存mSoftBitmapCache，并设置LRUCache的大小，这里设置为手机可用内存的1/4。</p>
<pre><code>int maxMemory=(int)Runtime.getRuntime().maxMemory()/4;
</code></pre><p>通过LRUCache构造方法的源码可以看出，实际上是初始化一个LinkedHashMap，并且LinkedHashMap中的对象采用LRU规则自动排序。</p>
<pre><code>public LruCache(int maxSize) {
    ... ...
    this.maxSize = maxSize;
    this.map = new LinkedHashMap(0, 0.75f, true);
}
public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {
    super(initialCapacity, loadFactor);
    init();
    this.accessOrder = accessOrder;
}
</code></pre><p>在LruCache中初始化LinkedHashMap构造方法的accessOrder参数值为true，这个参数默认为false，表示对象按照插入顺序排序。下面是LruCache类的get方法：</p>
<pre><code> public V get(Object key) {
    ... ...
    for (HashMapEntry e = tab[hash &amp; (tab.length - 1)];
            e != null; e = e.next) {
        K eKey = e.key;
        if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) {
            if (accessOrder)
                makeTail((LinkedEntry) e);
            return e.value;
        }
    }
    return null;
}
</code></pre><p>当向缓存get数据时，如果accessOrder为true，则通过makeTail((LinkedEntry) e)方法将对象移到了末尾， 这样就能够保证每次从头部移除最近最少使用的对象。<br>        如果向LRUCache中插入图片对象，当缓存空间不足时，需要移除最近最少使用对象，由于LinkedHashMap已经做好了排序， 所以直接移除头部对象即可。<br>       下面是LRUCache的put方法：</p>
<pre><code>public final V put(K key, V value) {
   ... ...
    V previous;
    synchronized (this) {
        putCount++;
        size += safeSizeOf(key, value);
        previous = map.put(key, value);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }
    if (previous != null) {
        entryRemoved(false, key, previous, value);
    }
    trimToSize(maxSize);
    return previous;
}
</code></pre><p>其中safeSizeOf(key, value)用来获取待插入对象的大小，并对已占用内存进行累加。再看看这个方法：</p>
<pre><code>private int safeSizeOf(K key, V value) {
    int result = sizeOf(key, value);
    if (result &lt; 0) {
        throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);
    }
    return result;
}
</code></pre><p>返回的result通过sizeOf(key, value)这个方法获取，到这里我们明白了需要重写sizeOf方法， 这里用每行像素点所占用的字节数乘高度计算出图片大小。</p>
<pre><code>protected int sizeOf(String key, Drawable value) {
   if(value!=null) {
      if (value instanceof BitmapDrawable) {
         Bitmap bitmap = ((BitmapDrawable) value).getBitmap();
         return bitmap.getRowBytes() * bitmap.getHeight();
      } 
      return 1;
   }else{
      return  0;
   }
}
</code></pre><p>然而真正移除对象是在trimToSize(maxSize)这个方法中：</p>
<pre><code>public void trimToSize(int maxSize) {
    while (true) {
        K key;
        V value;
        synchronized (this) {
            ... ...
            if (size &lt;= maxSize || map.isEmpty()) {
                break;
            }
            Map.Entry toEvict = map.entrySet().iterator().next();
            key = toEvict.getKey();
            value = toEvict.getValue();
            map.remove(key);
            size -= safeSizeOf(key, value);
            evictionCount++;
        }
        entryRemoved(true, key, value, null);
    }
}
</code></pre><p>这里会检查当前缓存容量，size &lt;= maxSize便移除头部对象。最后调用了entryRemoved(true, key, value, null)方法。</p>
<p>因此，我们可以重写该方法来处理淘汰对象：</p>
<pre><code>protected void entryRemoved(boolean evicted, String key, Drawable oldValue, Drawable newValue) {
   if (evicted) {
      if (oldValue != null) {
         //当硬缓存满了,根据LRU规则移入软缓存
         synchronized(mSoftBitmapCache) {
            mSoftBitmapCache.put(key, new SoftReference(oldValue));
         }
      }
   }else{//主动移除,回收无效空间
      recycleDrawable(oldValue);
   }
}
</code></pre><p>当evicted变量为true时，属于为腾出缓存空间被调用，将被淘汰的对象插入软引用缓存mSoftBitmapCache中。</p>
<p>当evicted变量为false时，属于主动淘汰对象，看下面代码：</p>
<pre><code>public final V remove(K key) {
    ... ...
    V previous;
    synchronized (this) {
        previous = map.remove(key);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }
    if (previous != null) {
        entryRemoved(false, key, previous, null);
    }
    return previous;
}
</code></pre><p>entryRemoved方法在LRUCache的remove方法中调用时，evicted参数的值为false，因此这里直接回收图片对象。 </p>
<p>如果软引用缓存mSoftBitmapCache超出上限，也根据LRU规则进行淘汰，直接回收对象的内存空间。这里参考LRUCache的实现方式进行初始化：</p>
<pre><code>this.mSoftBitmapCache= new LinkedHashMap&gt;(SOFT_CACHE_SIZE, 0.75f, true){ 
   @Override
   protected boolean removeEldestEntry(Entry&gt; eldest) {
      if (size() &gt; SOFT_CACHE_SIZE) {//缓存数量不超过10
         if(eldest!=null){
            SoftReference bitmapReference=eldest.getValue();
            if(bitmapReference!=null){
               Drawable oldValue=bitmapReference.get();
               recycleDrawable(oldValue);
            }
         }
         return true;
      }
      return false;
   }
};
</code></pre><p>不同的是重写了removeEldestEntry方法，这个方法主要用于判断缓存容量是否超过上限，如果超出则回收被淘汰的对象。</p>
<p>再看看LinkedHashMap类的put方法调用了addNewEntry方法，在该方法中会根据removeEldestEntry方法的返回来决定是否移除对象：</p>
<pre><code>public V put(K key, V value) {
        ... ...
    addNewEntry(key, value, hash, index);
    return null;
}
void addNewEntry(K key, V value, int hash, int index) {
    LinkedEntry header = this.header;
    // Remove eldest entry if instructed to do so.
    LinkedEntry eldest = header.nxt;
    if (eldest != header &amp;&amp; removeEldestEntry(eldest)) {
       remove(eldest.key);
    }
        ......
}
</code></pre><p>因此，当size() &gt; SOFT_CACHE_SIZE时，便对老对象进行移除操作。 从缓存中获取对象的方法：</p>
<pre><code>public Drawable getBitmap(String url){
  // 先从硬缓存中获取
  Drawable bitmap = get(url);
  if (bitmap != null) {
     return bitmap;
  }
  synchronized (mSoftBitmapCache) {
     SoftReference bitmapReference = mSoftBitmapCache.get(url);
     if (bitmapReference != null) {
        bitmap = bitmapReference.get();
        if (bitmap != null) {
           //移入硬缓存
           put(url, bitmap);
           mSoftBitmapCache.remove(url);
           return bitmap;
        } else {
           mSoftBitmapCache.remove(url);
        }
     }
  }
  return null;
}
</code></pre><p>优先从硬缓存中拿，如果存在则返回。否则查询软引用缓存，存在则返回对象并移入硬缓存中。</p>
<p>最后上完整的代码：</p>
<pre><code>public class BitmapLRUCache extends LruCache {
   private final int SOFT_CACHE_SIZE = 10; // 软引用缓存容量
   private LinkedHashMap&gt; mSoftBitmapCache;//软引用缓存,已清理的数据可能会再次使用
   public BitmapLRUCache(int maxSize) {
      super(maxSize);
      this.mSoftBitmapCache= new LinkedHashMap&gt;(SOFT_CACHE_SIZE, 0.75f, true){// true 采用LRU排序,移除队首
         @Override
         protected boolean removeEldestEntry(Entry&gt; eldest) {
            if (size() &gt; SOFT_CACHE_SIZE) {//缓存数量不超过10
               if(eldest!=null){
                  SoftReference bitmapReference=eldest.getValue();
                  if(bitmapReference!=null){
                     Drawable oldValue=bitmapReference.get();
                     recycleDrawable(oldValue);
                  }
               }
               return true;
            }
            return false;
         }
      };
   }
   public Drawable getBitmap(String url){
      // 先从硬缓存中获取
      Drawable bitmap = get(url);
      if (bitmap != null) {
         return bitmap;
      }
      synchronized (mSoftBitmapCache) {
         SoftReference bitmapReference = mSoftBitmapCache.get(url);
         if (bitmapReference != null) {
            bitmap = bitmapReference.get();
            if (bitmap != null) {
               //移入硬缓存
               put(url, bitmap);
               mSoftBitmapCache.remove(url);
               return bitmap;
            } else {
               mSoftBitmapCache.remove(url);
            }
         }
      }
      return null;
   }
   private  int getSizeInBytes(Bitmap bitmap) {
      int size = bitmap.getRowBytes() * bitmap.getHeight();//每一行像素点所占用的字节数 *  高度
      return size;
   }
   protected int sizeOf(String key, Drawable value) {
      if(value!=null) {
         if (value instanceof BitmapDrawable) {
            Bitmap bitmap = ((BitmapDrawable) value).getBitmap();
            return getSizeInBytes(bitmap);
         }
         return 1;
      }else{
         return  0;
      }
   }
   protected void entryRemoved(boolean evicted, String key, Drawable oldValue, Drawable newValue) {
      super.entryRemoved(evicted, key, oldValue, newValue);
      if (evicted) {
         if (oldValue != null) {
            //当硬缓存满了,根据LRU规则移入软缓存
            synchronized(mSoftBitmapCache) {
               mSoftBitmapCache.put(key, new SoftReference(oldValue));
            }
         }
      }else{//主动移除,回收无效空间
         recycleDrawable(oldValue);
      }
   }
   private void recycleDrawable(Drawable oldValue) {
      if (oldValue != null) {
         try {
            if (oldValue instanceof BitmapDrawable) {
               Bitmap bitmap = ((BitmapDrawable) oldValue).getBitmap();
               bitmap.recycle();
            }
            Log.i(&quot;BitmapLRUCache&quot;, &quot;oldValue：&quot; + oldValue);
         } catch (Exception exception) {
            Log.i(&quot;BitmapLRUCache&quot;, &quot;Failed to clear Bitmap images on close&quot;, exception);
         } finally {
            oldValue = null;
         }
      }
   }
}
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试机器为华为G525,系统版本为4.1。运行改进后的代码，在AndroidStudio中查看Monitors栏，启动程序并进行简单操作，很清楚的看到内存占用的实时变化以及释放的过程。</p>
<p><strong>改进前：</strong></p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/%E4%BC%98%E5%8C%96%E5%89%8D.jpg" alt="改进前"> </p>
<p><strong>改进后:</strong></p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/%E4%BC%98%E5%8C%96%E5%90%8E.jpg" alt="改进后"> </p>
<p>改进前内存保持在30M到40M之间，并且通过log日志观察GC暂停时间相对较长。改进后内存保持在20M以下。测试结果，有效的降低了内存占用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>应用程序过高的内存占用，资源不能及时释放，容易导致OOM。但内存占用也不是越少就越好，如果为了保持较低的内存占用而频繁触发GC操作，可能会造成程序性能的整体下降。因此，需要在实践中进行综合考虑做一定的权衡。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.jianshu.com/p/f5d8d3066b36" target="_blank" rel="external">http://www.jianshu.com/p/f5d8d3066b36</a></p>
<p><a href="https://my.oschina.net/u/586684/blog/226056" target="_blank" rel="external">https://my.oschina.net/u/586684/blog/226056</a></p>
<p><a href="http://www.bozhiyue.com/anroid/boke/2016/0521/132735.html" target="_blank" rel="external">http://www.bozhiyue.com/anroid/boke/2016/0521/132735.html</a></p>
<p><a href="http://blog.chinaunix.net/uid-26930580-id-4138306.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26930580-id-4138306.html</a></p>
<p><a href="https://developer.android.com/index.html" target="_blank" rel="external">https://developer.android.com/index.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpeg"
               alt="潘威" />
          <p class="site-author-name" itemprop="name">潘威</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潘威</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


</body>
</html>

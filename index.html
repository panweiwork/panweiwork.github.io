<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description"></h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/Kotlin重构实践/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/25/Kotlin重构实践/" itemprop="url">
                  Kotlin重构实践
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-25T18:40:56+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今年的 Google I/O 大会上，Google 宣布为 Kotlin 提供最佳支持，未来将成为 Android 的第一语言。最近在项目中已经开始用到，也踩过不少坑，这里做一个阶段性的总结。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>Kotlin 作为一种新的 JVM 语言，在设计时就考虑了 Java 互操作性，可以和 Java 代码混着一起写，也可以单独放在 src/main/kotlin 下。为了不破坏现有工程代码，将 Kotlin 代码单独存放，便于重构和开发。</p>
<p>举个例子，要使用某个控件，传统的写法是先 findViewById ，然后强转类型拿到引用，如果布局比较复杂，将会看到一大坨恶心代码。Kotlin 可以通过id直接使用控件，所以重构过程中将ButterKnife给淘汰了。。</p>
<h3 id="Android-Extensions"><a href="#Android-Extensions" class="headerlink" title="Android Extensions"></a>Android Extensions</h3><p>Kotlin 帮我们做了一些事情，只需一行代码</p>
<pre><code>import kotlinx.android.synthetic.main.＜布局＞.*
</code></pre><p>便能扩展对应的控件属性。<br>插件实现代码在 plugins/android-extensions 目录下，</p>
<p><strong>AndroidPackageFragmentProviderExtension.kt</strong></p>
<pre><code>    // Packages with synthetic properties
for (variantData in moduleData.variants) {
    for ((layoutName, layouts) in variantData.layouts) {
        fun createPackageFragment(fqName: String, forView: Boolean, isDeprecated: Boolean = false) {
            val resources = layoutXmlFileManager.extractResources(AndroidLayoutGroupData(layoutName, layouts), module)
            val packageData = AndroidSyntheticPackageData(moduleData, forView, isDeprecated, resources)
            val packageDescriptor = AndroidSyntheticPackageFragmentDescriptor(
                    module, FqName(fqName), packageData, lazyContext, storageManager, isExperimental,
                    lookupTracker, layoutName
            )
            packagesToLookupInCompletion += packageDescriptor
            allPackageDescriptors += packageDescriptor
        }

        val packageFqName = AndroidConst.SYNTHETIC_PACKAGE + &apos;.&apos; + variantData.variant.name + &apos;.&apos; + layoutName

        createPackageFragment(packageFqName, false)
        createPackageFragment(packageFqName + &quot;.view&quot;, true)
    }
}
</code></pre><p>packageFqName 表示import的虚拟包名，建立布局文件的引用。解析布局文件的逻辑在 <strong>AndroidLayoutXmlFileManager.kt</strong> 中，看它的 extractResources 方法！</p>
<pre><code>fun extractResources(layoutGroupFiles: AndroidLayoutGroupData, module: ModuleDescriptor): List&lt;AndroidResource&gt; {
    return filterDuplicates(doExtractResources(layoutGroupFiles, module))
}
...
protected abstract fun doExtractResources(layoutGroup: AndroidLayoutGroupData, module: ModuleDescriptor): AndroidLayoutGroup
</code></pre><p>主要逻辑在 doExtractResources 方法中，它其实是一个抽象方法，具体实现在 <strong>IDEAndroidLayoutXmlFileManager.kt</strong></p>
<pre><code>override fun doExtractResources(layoutGroup: AndroidLayoutGroupData, module: ModuleDescriptor): AndroidLayoutGroup {
    val layouts = layoutGroup.layouts.map { layout -&gt;
        val resources = arrayListOf&lt;AndroidResource&gt;()
        layout.accept(AndroidXmlVisitor { id, widgetType, attribute -&gt;
            resources += parseAndroidResource(id, widgetType, attribute.valueElement)
        })
        AndroidLayout(resources)
    }

    return AndroidLayoutGroup(layoutGroup.name, layouts)
}
</code></pre><p>读取 xml 标签的逻辑在 <strong>AndroidXmlVisitor.kt</strong> 中，上面传入了一个回调方法作为参数，用来记录遍历标签的 Id 和 Tpye 信息。</p>
<pre><code>class AndroidXmlVisitor(val elementCallback: (ResourceIdentifier, String, XmlAttribute) -&gt; Unit) : XmlElementVisitor() {

    ...

    override fun visitXmlTag(tag: XmlTag?) {
        val localName = tag?.localName ?: &quot;&quot;
        if (isWidgetTypeIgnored(localName)) {
            tag?.acceptChildren(this)
            return
        }

        val idAttribute = tag?.getAttribute(AndroidConst.ID_ATTRIBUTE_NO_NAMESPACE, AndroidConst.ANDROID_NAMESPACE)
        if (idAttribute != null) {
            val idAttributeValue = idAttribute.value
            if (idAttributeValue != null) {
                val xmlType = tag.getAttribute(AndroidConst.CLASS_ATTRIBUTE_NO_NAMESPACE)?.value ?: localName
                val name = androidIdToName(idAttributeValue)
                if (name != null) elementCallback(name, xmlType, idAttribute)
            }
        }

        tag?.acceptChildren(this)
    }
}
</code></pre><p>androidIdToName 方法用正则表达式提取出id的名称。代码在 <strong>AndroidConst.kt</strong> 中</p>
<pre><code>object AndroidConst {
    fun androidIdToName(id: String): ResourceIdentifier? {
        val values = AndroidConst.IDENTIFIER_REGEX.matchEntire(id)?.groupValues ?: return null
        val packageName = values[3]
        return ResourceIdentifier(values[4], if (packageName.isEmpty()) null else packageName)
    }
}
</code></pre><p>到这里大概就能明白，Activity 中为啥能够直接使用布局中的View了。。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>Kotlin 能够扩展一个类的新功能而无需继承该类，前面介绍了类属性的扩展，那么如何扩展一个类的方法呢？声明一个扩展函数，使用被扩展的类作为前缀，就拿 Context 类来说：</p>
<pre><code>//ContextExtensions.kt
inline fun &lt;reified T : Activity&gt; Context.startActivity(
        params: Map&lt;String, String?&gt;?) {
    val intent = Intent(this, T::class.java)
    var setEntry = params?.entries
    setEntry?.forEach { intent.putExtra(it.key, it.value) }
    startActivity(intent)
}
</code></pre><p>函数在 Kotlin 中作为第一等公民，可以在文件的最顶层声明，无需要像 Java 一样创建一个类来保存。这里 this 关键字对应函数的调用者对象。<br>最后，在 Activity 定义的 startActivity 方法中调用：</p>
<pre><code>class InviteMemberActivity : BaseActivity(), IView {
     ...
    companion object {
        fun startActivity(context: Context?, prjId: String?, prjName: String?, shortUrl: String?) {
            context?.let {
                val params = mapOf(PROJECT_ID to prjId, PROJECT_NAME to prjName, SHORT_URL to shortUrl)
                it.startActivity&lt;InviteMemberActivity&gt;(params)
            }
        }
    }
}
</code></pre><p>说明一下， Kotlin 中没有 static 方法，因此相应的方法应该放在 companion object 中，如果从 Java 中调用这些方法，需要添加 @JvmStatic 注解。另外，let 函数默认将当前对象作为闭包的 it 参数，返回值是函数里面最后一行，或者指定 return。如果上面 context 为 null，let 方法将不会执行！</p>
<h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>Kotlin 提供了一种数据类，只需要在 class 前面加上 data 关键字修饰，默认为所有属性实现了 getter、setter、equal、hashcode、toString 等方法，所以直接将项目中的 Lombok 框架给移除了。</p>
<p>Java 中一个普通的 POJO 可以如下定义：</p>
<pre><code>//POJO
data class ProjectDetailDTO(
    var prjStatus: Int = 0,
    var prjId: String? = null,
    var prjTitle: String? = null,
    var prjLabel: String? = null,
    var prjDesc: String? = null, 
    var prjNotice: String? = null,
     ...
)

//java
public class MapperOnData {
    ...
    public static ProjectDetailDTO fromPO(ProjectDetailPO src) {
        if (src == null) {
            return null;
        }
        ProjectDetailDTO dest = new ProjectDetailDTO();
        ...
        return dest;
    } 
    ...
}    
</code></pre><p>这里要注意，数据类不能被 abstract, open, sealed、inner 关键字修饰。为了兼容 MapperOnData 工具类，需要包含一个无参构造函数，所以给所有属性都指定了默认值。</p>
<p>Kotlin 的语法不仅简洁、高效，同时还支持 Lamada 表达式、操作符、空安全、类型检查与转换等等，实际开发中代码精简行数接近一半。这里我不再一一举例，可以参考 <a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">语法</a> 、<a href="https://android.github.io/kotlin-guides/style.html" target="_blank" rel="external">Style guide</a></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>重构是为了优化代码结构，使用上新语言的特性，让代码更容易理解。重构过程中，为了确保业务逻辑不丢失，通过单元测试覆盖所有场景，每次编译都会跑一遍测试用例，只有所有用例通过才能构建成功。</p>
<p>由于项目的原子性业务逻辑主要集中在 Presenter 和 UseCase 类中，因此也非常方便写测试用例。项目中使用了 Junit + Mockito + Powermock + Robolectric 框架，测试代码编译成 class 文件直接运行在 JVM 上。</p>
<p>引入 Powermock 是因为它支持 static、final、private 方法的 mock， Powermock 会创建一个新的 MockClassLoader 来加载测试用例，然后修改字节码来实现对 static 、 final 等方法的 mock。</p>
<blockquote>
<p>Kotlin 中类、方法都默认为 final 的，除非使用 open 来修饰，否则 mock 桩类会报错。</p>
</blockquote>
<p><strong>如何进行测试？</strong></p>
<p>1、添加依赖：</p>
<pre><code>testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;
</code></pre><blockquote>
<p>提供了4个注解：@Test、 @Ignore、 @BeforeTest 和 @AfterTest，这些注解会映射到相应 JUnit 4 注解</p>
</blockquote>
<p>然后在 src/test/resourcesorg/powermock/extensions/configuration.properties 中添加：</p>
<pre><code>mockito.mock-maker-class=mock-maker-inline
</code></pre><blockquote>
<p>注：Powermock 在1.7.0后实现了自己的 PowerMockMaker，目前只是简单代理了 Mockito 的 MockMaker 和修复一些已知 bug。</p>
</blockquote>
<p>2、编写测试用例。包括三个部分：</p>
<ul>
<li>数据准备。mock桩类、预设条件返回值。</li>
<li>待测试方法、成员变量调用。</li>
<li>验证。方法是否被调用、逻辑分支是否覆盖完全、返回值或属性状态是否符合预期。</li>
</ul>
<p>3、执行用例。</p>
<pre><code>./gradlew testDevReleasegUnitTest
</code></pre><p>我们的 UseCase 类中包含由 Retrofit 框架提供的 Observable，同时封装了 RxJava 的线程管理逻辑。这里使用 RxJava 提供的 TestSubscriber 类来测试，看代码：</p>
<pre><code>import org.mockito.Mockito.`when` as _when

@Before
fun setup() {
    mSubscriber = TestSubscriber()
}

@Test
@Throws(Exception::class)
fun testSetTabRemind_Person_Successs() {
       //1、准备
    _when(mRepository.updateMyTabRemindUsingPOST(ArgumentMatchers.anyString())).thenReturn(Observable.just(true))

    //2、调用
    mUseCase.setParam(ArgumentMatchers.anyString(), TabPerson)
    mUseCase.execute(mSubscriber)
    mSubscriber.awaitTerminalEvent()

    //3、验证
    verify&lt;IRepository&gt;(mRepository, never()).updateToDoTabRemindUsingPOST(ArgumentMatchers.anyString())
    verify&lt;IRepository&gt;(mRepository, times(1)).updateMyTabRemindUsingPOST(ArgumentMatchers.anyString())
    mSubscriber.assertNoErrors()
    mSubscriber.assertValue(true)
    mSubscriber.assertCompleted()
}
</code></pre><blockquote>
<p>由于 when 是 Kotlin 的保留关键字，所以对方法名做了转换 <code>when</code> as _when</p>
</blockquote>
<p>下面测试 MyProjectPresenter 的一个方法：</p>
<pre><code>@Before
override fun setUp() {
    super.setUp()
    view = PowerMockito.mock(IMyProjectView::class.java)
    mHomeUseCase = PowerMockito.spy(HomeUseCase())
    mPresenter = PowerMockito.spy(MyProjectPresenter())

    mPresenter.mMyProjectFragment = view
    mPresenter.mHomeUseCase = mHomeUseCase
}

@Test
@PrepareForTest(AppInfo::class)
fun testGetMyProjects_WhenLoadData_ThenSuccess() {
       //1、准备
    PowerMockito.mockStatic(AppInfo::class.java)
    var appInfo = PowerMockito.mock(AppInfo::class.java)
    PowerMockito.`when`(appInfo.userId).thenReturn(&quot;123&quot;)
    PowerMockito.`when`(AppInfo.getInstance()).thenReturn(appInfo)

    var projectDetail = ProjectDetailDTO()
    var list = ArrayList&lt;ProjectDetailDTO&gt;()
    list.add(projectDetail)
    mockUcBusiness(mHomeUseCase, Observable.just(list))

    //2、调用
    mPresenter.getMyProjects()

    //3、验证
    verifyBusiness(mHomeUseCase)
    verify(view).hideInitial()
    verify(view).refreshComplete()
    verify(view).render(any())
}
</code></pre><p>另外，测试用例不可避免会调用Android系统的API，在编译阶段我们依赖的是 android.jar，它没有任何实现，所有方法都是 throw new RuntimeException(“Stub!”)，只有运行在真实的Android系统上才会去加载 Framework 层的实现代码。那么运行在 JVM 上的测试代码便会出错，如果采用Mock桩类的方式，用例会比较繁琐。所以又引入 Robolectric 来解决这个问题，它实现了一套能运行在 JVM 上的 Android Shadow 代码，模拟系统 API 的调用过程。</p>
<h2 id="Dagger、Retrofit-amp-RxJava"><a href="#Dagger、Retrofit-amp-RxJava" class="headerlink" title="Dagger、Retrofit &amp; RxJava"></a>Dagger、Retrofit &amp; RxJava</h2><p>Kotlin 依然支持 Retrofit、RxJava、Dagger2 等开源框架。通过 kapt 编译器插件支持注解处理器，kapt 同样能够处理 Java 文件，是时候替换掉默认的 annotationProcessor 了。下面介绍如何使用 Dagger2：</p>
<p>在 build.gradle 中添加：</p>
<pre><code>apply plugin: &apos;kotlin-kapt&apos;
dependencies {
    kapt &quot;com.google.dagger:dagger-compiler:${DAGGER_VERSION}&quot;
 }
</code></pre><p>先实现主模块！</p>
<p><strong>ApplicationComponent</strong></p>
<pre><code>//java
@Singleton
@Component(modules = { ApplicationModule.class })
public interface ApplicationComponent {
    void inject(BimApplication application);
    ...
}
</code></pre><p><strong>ApplicationModule</strong></p>
<pre><code>@Module
class ApplicationModule(val application: BimApplication) {
    @Provides
    fun provideBimApplication() = application

     @Provides
    fun provideBimRetrofit(okHttpClient: OkHttpClient): Retrofit{
        ...
    }
     ...
}
</code></pre><p>在 BimApplication 的 OnCreat 方法中注入：</p>
<pre><code>//java
DaggerApplicationComponent.builder()
            .applicationModule(new ApplicationModule(this))
            .build().inject(this)
</code></pre><p>其中，ApplicationModule 提供全局使用的实例对象。</p>
<p>接下来，在 Activity 的生命周期内实现分模块：</p>
<p>定义 Base Module 类 <strong>AbsActivityModule</strong></p>
<pre><code>@Module
abstract class AbsActivityModule&lt;T : Activity&gt;(@JvmField var mActivity: T) {

    @Provides
    fun provideHostActivity(): T {
        return mActivity
    }
}
</code></pre><p><strong>ProjectNoticeComponent</strong></p>
<pre><code>@PerActivity
@Component(dependencies = [ApplicationComponent::class], modules = [ProjectNoticeComponent.ProjectNoticeModule::class])
interface ProjectNoticeComponent : MembersInjector&lt;ProjectNoticeActivity&gt; {

    @Module
    class ProjectNoticeModule(activity: ProjectNoticeActivity) : AbsActivityModule&lt;ProjectNoticeActivity&gt;(activity)
}
</code></pre><blockquote>
<p>与Java不同，Kotlin 中默认为静态内部类，成员内部类则用 inner 关键字修饰。</p>
</blockquote>
<p>为了方便，将 Activity 的 Component 和 Module 放在了一起。最后，Activity中注入：</p>
<pre><code>class ProjectNoticeActivity : BaseActivity(), IProjectNoticeView {
    override fun onCreate(savedInstanceState: Bundle?) {
           super.onCreate(savedInstanceState)
        DaggerProjectNoticeComponent.builder()
                .applicationComponent(applicationComponent)
                .projectNoticeModule(ProjectNoticeComponent.ProjectNoticeModule(this))
                .build()
                .injectMembers(this)
    }
</code></pre><p>Kotlin 中使用 Dagger2 是不是非常简单？Module 负责生产对象，需要使用的地方直接 @Inject 即可，项目中所有的 Presenter 和 UseCase 都是可以直接使用的，让代码进一步解耦。</p>
<p>第一节中我们使用 data 关键字定义了数据类，它可以用来承载 Json 转换过来的 Response 数据。下面将实现一个标准的网络请求。</p>
<p>创建一个API Interface文件 <strong>BimApi.kt</strong>:</p>
<pre><code>interface BimApi {
    ...
    @FormUrlEncoded
    @POST(&quot;api/m/project/modify&quot;)
    fun modifyProject(@Field(&quot;prjId&quot;) prjId: String?, @Field(&quot;prjTitle&quot;) prjTitle: String?,
                      @Field(&quot;prjNotice&quot;) prjNotice: String?): Observable&lt;ProjectDetailDTO&gt;
}
</code></pre><p>使用 Dagger 注入全局的 Retrofit 对象：</p>
<pre><code>@Singleton
class KCloudDataStore
@Inject
constructor(retrofit: Retrofit){
    ...
    fun modifyProject(prjId: String?, prjTitle: String?, prjNotice: String?): Observable&lt;ProjectDetailDTO&gt; {
        return retrofit.create(BimApi::class.java).modifyProject(prjId, prjTitle, prjNotice)
    }
}
</code></pre><p>实现了一个访问网络的方法供上层调用，并且采用 RxJava 来管理异步线程。如图：</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/KotlinRefactor/Bim%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="结构图"></p>
<p>从网络层拿到 Observable 对象，然后在 UseCase 中 subscribe </p>
<pre><code>Observable&lt;ProjectDetailDTO&gt; 
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe (object : DefaultSubscriber&lt;ProjectDetailDTO&gt;() {
        override fun onNext(projectDetailDTO: ProjectDetailDTO?) {
            super.onNext(projectDetailDTO)
            //UI Thread
            //TODO
        }
    })
</code></pre><blockquote>
<p>object 关键字声明匿名内部类</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>目前，新的功能已完全使用 Kotlin 进行开发，底层封装的一些通用模块暂时兼容 Java，后续会不断进行重构，直至完全切换到 Kotlin。同时，新的语言还需要一个熟悉的过程，使用上难免会产生疏忽和偏差，比如，lateinit var修饰的属性，使用前如果未初始化，运行时会报  kotlin.UninitializedPropertyAccessException。</p>
<p>尚未使用的特性，如反射、协程等。除此之外，Kotlin 几乎可以用于任何类型的开发，无论是服务器端、Web、Android 还是 Native。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kotlinlang.org/docs/reference" target="_blank" rel="external">https://kotlinlang.org/docs/reference</a></p>
<p><a href="https://android.github.io/kotlin-guides/style.html" target="_blank" rel="external">https://android.github.io/kotlin-guides/style.html</a></p>
<p><a href="https://github.com/JetBrains/kotlin" target="_blank" rel="external">https://github.com/JetBrains/kotlin</a></p>
<p><a href="https://github.com/powermock/powermock/wiki/Mockito" target="_blank" rel="external">https://github.com/powermock/powermock/wiki/Mockito</a></p>
<p><a href="https://blog.jetbrains.com/kotlin" target="_blank" rel="external">https://blog.jetbrains.com/kotlin</a></p>
<p><a href="https://android.jlelse.eu/keddit-part-9-unit-test-with-kotlin-mockito-spek-76709812e3b6" target="_blank" rel="external">https://android.jlelse.eu/keddit-part-9-unit-test-with-kotlin-mockito-spek-76709812e3b6</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/Jenkins之静态代码检查/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/14/Jenkins之静态代码检查/" itemprop="url">
                  Jenkins之静态代码检查
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-14T20:04:56+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>编码过程中不可避免会产生一些错误，如何借助工具来发现这些问题，帮助我们有效的改进代码质量。最近在项目中接入了Checksytle、Findbugs、PMD 和 Android Lint等自动化工具，AndroidStudio中都有对应的插件。本文只介绍Gradle方式，Gradle Task配合Jenkins来实时执行任务检查，方便后续的日志追踪。</p>
<p>首先，在build.gradle文件中添加：</p>
<pre><code>apply plugin: &apos;findbugs&apos;
apply plugin: &apos;checkstyle&apos;
apply plugin: &apos;pmd&apos;
</code></pre><p>接下来配置这些工具。</p>
<h1 id="Checkstyle"><a href="#Checkstyle" class="headerlink" title="Checkstyle"></a>Checkstyle</h1><p>主要是代码格式、规范的检查，可自定义扫描规则。我之前的一篇<a href="http://note.youdao.com/noteshare?id=3743e5e9baff7566955dc2af45b47b7e" target="_blank" rel="external">文章</a></p>
<pre><code>task checkstyle(type: Checkstyle) {
    ignoreFailures true    
    showViolations = true
    configFile file(&quot;${project.rootDir}/settings/checkstyle.xml&quot;)

    source &apos;src/main/java&apos;
    include &apos;**/*.java&apos;
    exclude &apos;**/gen/**&apos;
    exclude &apos;**/R.java&apos;
    exclude &apos;**/BuildConfig.java&apos;

    // empty classpath
    classpath = files()
    reports {
        xml.enabled = false
        html.enabled = true
        xml {
            destination &quot;$project.buildDir/reports/checkstyle/checkstyle.xml&quot;
        }
        html {
            destination &quot;$project.buildDir/reports/checkstyle/checkstyle.html&quot;
        }
    }
}
</code></pre><blockquote>
<p>若要编写checkstyle.xml文件，请参考<a href="http://checkstyle.sourceforge.net/config.html" target="_blank" rel="external">传送门</a></p>
</blockquote>
<h1 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h1><p>FindBugs uses static analysis to inspect Java bytecode for occurrences of bug patterns.</p>
<p>静态分析方式扫描 Java 字节码，发现其中的可能出现 bug 的代码，它能发现一些常规的逻辑错误。</p>
<p><strong>注：必须先编译生成class文件，否则会报错</strong></p>
<pre><code>task findbugs(type: FindBugs,dependsOn: &quot;assembleQaRelease&quot;) {
    ignoreFailures = true
    effort = &quot;default&quot;
    reportLevel = &quot;medium&quot;
    excludeFilter = new File(&quot;${project.rootDir}/settings/findbugs-android-exclude.xml&quot;)
    classes = files(&quot;${project.rootDir}/app/build/intermediates/classes&quot;)
    source = fileTree(&apos;src/main/java/&apos;)
    classpath = files()
    reports {
        xml.enabled = false
        html.enabled = true
        xml {
            destination &quot;$project.buildDir/reports/findbugs/findbugs-output.xml&quot;
        }
        html {
            destination &quot;$project.buildDir/reports/findbugs/findbugs-output.html&quot;
        }
    }
}
</code></pre><blockquote>
<p>定义过滤文件，请参考 <a href="http://findbugs.sourceforge.net/manual/filter.html" target="_blank" rel="external">传送门</a></p>
</blockquote>
<h1 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a>PMD</h1><p>名字还没有统一的说法，下面是官网找到的几种解释：</p>
<ul>
<li>Pretty Much Done</li>
<li>Project Mess Detector</li>
<li>Project Monitoring Directives</li>
<li>Project Meets Deadline</li>
<li>Programming Mistake Detector</li>
<li>Pounds Mistakes Dead</li>
<li>PMD Meaning Discovery (recursion, hooray!)</li>
<li>Programs of Mass Destruction</li>
<li>Programming Meticulous coDe</li>
</ul>
<p>它是基于源码的检查，能扫描出废弃变量和对象、空catch语句等。不仅支持Java，还支持JS、XML等其他语言，与FindBugs形成互补。</p>
<pre><code>task pmd(type: Pmd) {
    ruleSetFiles = files(&quot;${project.rootDir}/settings/pmd-ruleset.xml&quot;)
    ignoreFailures = true
    ruleSets = []

    source &apos;src&apos;
    include &apos;**/*.java&apos;
    exclude &apos;**/gen/**&apos;

    reports {
        xml.enabled = false
        html.enabled = true
        xml {
            destination &quot;$project.buildDir/reports/pmd/pmd.xml&quot;
        }
        html {
            destination &quot;$project.buildDir/reports/pmd/pmd.html&quot;
        }
    }
}
</code></pre><blockquote>
<p>自定义pmd-ruleset.xml文件，可参考 <a href="http://pmd.sourceforge.net/pmd-4.3.0/howtomakearuleset.html" target="_blank" rel="external">传送门</a></p>
</blockquote>
<h1 id="Android-Lint"><a href="#Android-Lint" class="headerlink" title="Android Lint"></a>Android Lint</h1><p>专门为Android工程打造的静态代码分析工具，除了检查潜在的问题外，还能对Android的资源文件、废弃无用资源进行扫描。</p>
<pre><code>android {
    lintOptions {
        checkReleaseBuilds true
        abortOnError true
        lintConfig file(&quot;lint.xml&quot;)
        htmlReport true
        htmlOutput file(&quot;$project.buildDir/reports/lint/lint.html&quot;)
    }
}
</code></pre><blockquote>
<p>lint.xml文件定义 Lint 检查项，置于 Android 项目的根目录。<a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">传送门</a></p>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这里要说明的是，FindBugs和PMD的输出文件有xml和html两种格式，同时启用两种格式会报错，解决办法是关掉其中一种，或者通过配置让脚本执行两遍。一般情况下，配置文件采用官方默认即可，也可根据团队需求自定义规则。</p>
<p>另外，自动化工具部分规则还存在争议，它能帮我们找出代码缺陷，但扫描结果还需开发人员确认是否修改或选择忽略。为了避免执行中断，建议启用ignoreFailures属性。</p>
<p>为了管理任务，添加check task的依赖：</p>
<pre><code>check.dependsOn &apos;checkstyle&apos;, &apos;findbugs&apos;, &apos;pmd&apos;, &apos;lint&apos;
</code></pre><p>然后输入：</p>
<pre><code>gradlew check
</code></pre><p>依次执行上面的任务。</p>
<p>Jenkins每小时都会去检查代码，如果产生变更则自动触发任务，并在项目面板中显示报告文件。如图：<br><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/CodeCheck/Jenkins-codecheck.jpeg" alt="report"></p>
<blockquote>
<p>本文所参考的项目 <a href="https://github.com/bufferapp/android-guidelines" target="_blank" rel="external">传送门</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/通知优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/15/通知优化/" itemprop="url">
                  通知优化
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-15T19:39:56+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在对项目中的Notification和短链跳转进行优化，APP退出之后，从外部进入目标页面，避免直接返回到桌面。Android系统采用任务栈来管理Activity。</p>
<p><img src="/images/notification/backstack.png" alt="任务栈"></p>
<p>目前返回是统一指向主页面，实现方式无非是两种：一是先启动再跳转，二先跳转目标页然后返回主页。</p>
<p>具体方案如下：</p>
<h2 id="一、TaskStackBuilder"><a href="#一、TaskStackBuilder" class="headerlink" title="一、TaskStackBuilder"></a>一、TaskStackBuilder</h2><p>用于构造返回任务栈，仅支持22以上的版本。<br>在AndroidManifest.xml配置Activity关系</p>
<pre><code>&lt;activity android:name=&quot;.NoticesActivity&quot;
      android:parentActivityName=&quot;.HomeActivity&quot;/&gt;
</code></pre><p>系统会读取该属性，以确定当用户返回时应该启动哪一个Activity。</p>
<p>代码</p>
<pre><code>//启动通知Activity时，拉起主页面Activity
Intent noticeIntent = new Intent();
noticeIntent.setClass(this, NoticesActivity.class);

//创建返回栈
TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);
//添加Activity到返回栈
stackBuilder.addParentStack(HomeActivity.class);
//添加Intent到栈顶
stackBuilder.addNextIntent(noticeIntent);

PendingIntent pendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);
</code></pre><h2 id="二、PendingIntent-getActivities"><a href="#二、PendingIntent-getActivities" class="headerlink" title="二、PendingIntent.getActivities()"></a>二、PendingIntent.getActivities()</h2><p>先看看官方的解释：</p>
<p><img src="/images/notification/getActivities.jpeg" alt="getActivities"></p>
<p>首先需要构建一个Intent数组，其中第一个Intent对象将会被额外的启动一个栈（启动模式设置为singleTask），所以将HomeActivity设置为intents[0]对象.</p>
<p>而intents数组中最后一个，将作为PendIntent的关键，也就是点击之后需要跳转的目标页面。</p>
<p>代码：</p>
<pre><code>Intent noticeIntent = new Intent();
Intent homeIntent = new Intent();
noticeIntent.setClass(this, NoticesActivity.class);
homeIntent.setClass(this, HomeActivity.class);
//按顺序排列
Intent[] intents = new Intent[]{homeIntent, noticeIntent};
PendingIntent pendingIntent = PendingIntent.
        getActivities(this, 0, intents, PendingIntent.FLAG_UPDATE_CURRENT);
</code></pre><h2 id="三、启动多个页面"><a href="#三、启动多个页面" class="headerlink" title="三、启动多个页面"></a>三、启动多个页面</h2><p>1、过渡页中一次性启动多个页面</p>
<pre><code>Intent[] intents = {homeIntent, noticeIntent};
context.startActivities(intents);
</code></pre><p>2、在页面中依次按顺序启动页面，并管理传入的参数，实现不同目标页的跳转（稍微复杂）</p>
<h2 id="四、加一个flag，重构返回逻辑（实现简单）"><a href="#四、加一个flag，重构返回逻辑（实现简单）" class="headerlink" title="四、加一个flag，重构返回逻辑（实现简单）"></a>四、加一个flag，重构返回逻辑（实现简单）</h2><p>代码：</p>
<pre><code>Intent msgIntent =new Intent(context,ProjectDetailHomeActivity.class);
//判断是否是点击notification后到的详细界面
startIntent.putExtra(&quot;notificationFlag&quot;,true);
</code></pre><p>重写BaseActivity的返回逻辑</p>
<pre><code>notificationFlag =intent.getBooleanExtra(&quot;notificationFlag&quot;,false);
if(notificationFlag){
     Intent intent=new Intent(this,MainActivity.class);
     startActivity(intent);
     finish();
}
</code></pre><p>也可以重写Activity的onBackPressed（）方法，判断当前Activity是否处于任务栈的底部，如果是则跳转首页，否则正常返回。</p>
<blockquote>
<p>注意：为了确保Activity处于栈底，应该把启动模式设置为singleTask。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在项目中无法直接打开目标详情页，中间还需经过一个过度组件来准备数据，和相关初始化工作（权限、网络通信、状态更新、未登录等），所以方案一、二排除。由于通知类型较多，需要改造较多的目标页面，并对不同的flag进行管理，方案三实现略微复杂。最后采用了方案四！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/注解的那些事/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/24/注解的那些事/" itemprop="url">
                  注解的那些事
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-24T19:55:53+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是注解（Annotation）？"><a href="#什么是注解（Annotation）？" class="headerlink" title="什么是注解（Annotation）？"></a>什么是注解（Annotation）？</h1><p><strong>首先要回答为啥要使用注解？它能解决什么样的问题？</strong></p>
<blockquote>
<p>简单来说它能告诉编译器按我们的意图做一些事情，具有标识、减少代码量，让代码结构更加清晰的作用。</p>
</blockquote>
<p>For example，在Android开发过程中，要获取一个控件对象必须大量调用 findViewById()方法，并且还的进行类型强转，使用起来非常麻烦。</p>
<p>为了解决这个问题ButterKnife应运而生，只需添加一行注解便能实现xml控件的绑定。<br>除此之外，Retrofit、Rxjava、OKHttp等开源项目也大量使用了注解。</p>
<p><strong>总结一下,注解就是Java提供了一种源程序中的元素关联任何信息或者任何元数据（metadata）的途径和方法</strong>。</p>
<blockquote>
<p>它是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
</blockquote>
<p>常见的作用有以下几种：</p>
<ul>
<li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能。（retrofit网络配置）</li>
<li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</li>
</ul>
<h1 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h1><p>JDK1.5开始，Java提供了注解的功能，允许开发者定义和使用自己的注解类型，该功能由一个定义注解类型的语法和描述一个注解声明的语法，读取注解的API，一个使用注解修饰的class文件和一个注解处理工具组成。整个过程包括：注解定义、使用注解、初始化注解处理、处理注解。</p>
<h2 id="注解类型"><a href="#注解类型" class="headerlink" title="注解类型"></a>注解类型</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p> 元注解是指注解的注解。包括  @Retention @Target @Document @Inherited四种。</p>
<p><strong>1、@Retention: 定义注解的保留策略</strong></p>
<pre><code>@Retention(RetentionPolicy.SOURCE)//注解仅存在于源码中，在class字节码文件中不包含
@Retention(RetentionPolicy.CLASS)// 默认的保留策略，注解会在class字节码文件中存在，但运行时无法得
@Retention(RetentionPolicy.RUNTIME)// 注解会在class字节码文件中存在，在运行时可以通过反射获取到
</code></pre><p><strong>2、@Target：定义注解的作用目标</strong></p>
<p>其定义的源码为： </p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
 public @interface Target {
     ElementType[] value();
 }
@Target(ElementType.TYPE)   //接口、类、枚举、注解
@Target(ElementType.FIELD) //字段、枚举的常量
@Target(ElementType.METHOD) //方法
@Target(ElementType.PARAMETER) //方法参数
@Target(ElementType.CONSTRUCTOR)  //构造函数
@Target(ElementType.LOCAL_VARIABLE)//局部变量
@Target(ElementType.ANNOTATION_TYPE)//注解
@Target(ElementType.PACKAGE) ///包   
</code></pre><p>由以上的源码可以知道，他的elementType 可以有多个，一个注解可以为类的，方法的，字段的等等。</p>
<p><strong>3、@Document：说明该注解将被包含在javadoc中</strong></p>
<p><strong>4、@Inherited：说明子类可以继承父类中的该注解</strong></p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>Java中表示声明一个注解类的关键字。<br>使用@interface 表示我们已经继承了java.lang.annotation.Annotation类，这是一个注解的基类接口</p>
<pre><code>public @interface MyAnnotation { 

}
</code></pre><p>通常在使用时会为注解类加上两个注解：</p>
<pre><code>@Target(ElementType.TYPE,ElementType.METHOD)、
@Retention(RetentionPolicy.RUNTIME)
</code></pre><p>表示注解会在class字节码文件中存在，在运行时可以通过反射获取到。同时，该注解可以是类的注解或者方法的注解。</p>
<p>Annotation类型里面的参数设定: </p>
<ul>
<li>只能用public或默认(default)这两个访问权修饰.</li>
<li>成员变量只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String,Enum,Class,annotations等数据类型,以及这一些类型的数组。</li>
<li>成员变量以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。如果只有一个成员变量,最好把成员变量名称设为value.</li>
</ul>
<p>例如ButterKnife中 BindView注解的申明：</p>
<pre><code>@Retention(CLASS) @Target(FIELD)
public @interface BindView {
  /** View ID to which the field will be bound. */
  @IdRes int value();
}
</code></pre><h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><p>根据所标识的注解完成未完成的工作</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>利用Java的反射机制，但是运行时效率低下，因为JVM不能够在反射之前做任何假象和优化，另外在参数检查、可见性检查、调用权限、分配内存等方面仍然要占用更多的时间。如下代码实现了对象与控件的绑定：</p>
<pre><code>/**

 * @param currentClass

 *            当前类，一般为Activity或Fragment

 * @param sourceView

 *            待绑定控件的直接或间接父控件

 */

public static void initBindView(Object currentClass, View sourceView) {

    // 通过反射获取到全部属性，反射的字段可能是一个类（静态）字段或实例字段

    Field[] fields = currentClass.getClass().getDeclaredFields();

    if (fields != null &amp;&amp; fields.length &gt; 0) {

        for (Field field : fields) {

            // 返回BindView类型的注解内容

            BindView bindView = field.getAnnotation(BindView.class);

            if (bindView != null) {

                int viewId = bindView.id();

                boolean clickLis = bindView.click();

                try {

                    field.setAccessible(true);

                    if (clickLis) {

                        sourceView.findViewById(viewId).setOnClickListener(

                                (OnClickListener) currentClass);

                    }

                    // 将currentClass的field赋值为sourceView.findViewById(viewId)

                    field.set(currentClass, sourceView.findViewById(viewId));

                } catch (Exception e) {

                    e.printStackTrace();

                }

            }

        }

    }

}
</code></pre><h3 id="APT-Annotation-Processing-Tool"><a href="#APT-Annotation-Processing-Tool" class="headerlink" title="APT(Annotation Processing Tool)"></a>APT(Annotation Processing Tool)</h3><ul>
<li>注解处理器（AbstractProcess）</li>
<li>代码处理（JavaPoet库）</li>
<li>处理器注册（AutoService）</li>
<li><p>annotationProcessor(Android官方插件,在编译期间自动生成的代码,不会降低运行效率）</p>
<blockquote>
<p>Annotation处理器根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。</p>
</blockquote>
<p>常见的项目： Dagger2 、 ButterKnife<br><a href="http://blog.csdn.net/xx326664162/article/details/68490059" target="_blank" rel="external">http://blog.csdn.net/xx326664162/article/details/68490059</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>EventBus、Retrofit 属于反射，反射可以动态访问和修改对象，让代码更加灵活，处理不当会对性能造成影响。在如今硬件设备上，牺牲部分性能并不会影响用户体验。在实际项目中，可以考虑开发埋点注解框架，减少使用者的学习成本和出错率。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/26/进程保活/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/26/进程保活/" itemprop="url">
                  进程保活是耍流氓吗？
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-26T19:30:23+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>保活是不是耍流氓？</strong></p>
<p>很多场景如果要想为用户服务，就必须有一个进程常驻，以便在特定的时候做特定的事情。</p>
<p>1、实现IM，推送，定位等功能。</p>
<p>2、某些系统广播无法静态注册。</p>
<blockquote>
<p>android.intent.action.SCREEN_ON</p>
<p>android.intent.action.SCREEN_OFF</p>
<p>android.intent.action.BATTERY_CHANGED</p>
<p>android.intent.action.CONFIGURATION_CHANGED</p>
<p>android.intent.action.TIME_TICK</p>
</blockquote>
<p>存在问题：<br>增加系统性能开销，所以结合内存、电池等消耗找到一个平衡点。</p>
<p>Android系统中在没有白名单的情况下，要做到应用不被杀死基本不可能的，但是我们可以让应用尽可能的不被杀死，如果杀死也能够自动复活。</p>
<h1 id="Android进程的优先级"><a href="#Android进程的优先级" class="headerlink" title="Android进程的优先级"></a>Android进程的优先级</h1><p>1、前台进程(Foreground process)</p>
<ul>
<li>某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。 </li>
<li>某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。 </li>
<li>某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。 </li>
<li>某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。 </li>
<li>某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。</li>
</ul>
<p>表示用户正在使用的程序，一般系统是不会杀死前台进程的，除非用户强制停止应用或者系统内存不足等极端情况会杀死。</p>
<p>2、可见进程(Visible process)</p>
<ul>
<li>拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。 </li>
<li>拥有绑定到可见（或前台）Activity 的 Service</li>
</ul>
<p>用户仅仅可见，无法交互！<br>一般系统也是不会杀死可见进程的，除非要在资源吃紧的情况下，要保持某个或多个前台进程存活</p>
<p>3、服务进程(Service process)</p>
<ul>
<li>某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。</li>
</ul>
<p>在内存不足以维持所有前台进程和可见进程同时运行的情况下，服务进程会被杀死</p>
<p>4、后台进程(Background process)</p>
<ul>
<li>在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onStop方法</li>
</ul>
<p>系统可能随时终止它们，回收内存</p>
<p>5、空进程(Empty process)</p>
<ul>
<li>某个进程不包含任何活跃的组件时该进程就会被置为空进程，</li>
</ul>
<p>完全没用,直接干掉</p>
<h1 id="Android进程的回收策略"><a href="#Android进程的回收策略" class="headerlink" title="Android进程的回收策略"></a>Android进程的回收策略</h1><p>系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app, 这套杀进程回收内存的机制就叫<strong>Low Memory Killer</strong>，位于kernel层。</p>
<p>不同手机的内存阈值也不同，可以通过cat /sys/module/lowmemorykiller/parameters/minfree文件查看，一旦低于该值,Android便开始按顺序关闭进程。因此Android最先结束优先级最低的空进程。</p>
<p>进程的优先级是通过进程的oom_adj值来反映的。Linux内核为每个系统进程分配了一个oom_adj值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收，oom_adj值定义在com.android.server.am.ProcessList类中。</p>
<table>
<thead>
<tr>
<th>adj级别</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNKNOWN_ADJ</td>
<td>16</td>
<td>预留的最低级别，一般对于缓存的进程才有可能设置成这个级别</td>
</tr>
<tr>
<td>CACHED_APP_MAX_ADJ</td>
<td>15</td>
<td>缓存进程，空进程，在内存不足的情况下就会优先被kill</td>
</tr>
<tr>
<td><strong>CACHED_APP_MIN_ADJ</strong></td>
<td>9</td>
<td>缓存进程，也就是空进程</td>
</tr>
<tr>
<td><strong>SERVICE_B_ADJ</strong></td>
<td>8</td>
<td>不活跃的进程</td>
</tr>
<tr>
<td>PREVIOUS_APP_ADJ</td>
<td>7</td>
<td>切换进程</td>
</tr>
<tr>
<td>HOME_APP_ADJ</td>
<td>6</td>
<td>与Home交互的进程</td>
</tr>
<tr>
<td><strong>SERVICE_ADJ</strong></td>
<td>5</td>
<td>有Service的进程</td>
</tr>
<tr>
<td>HEAVY_WEIGHT_APP_ADJ</td>
<td>4</td>
<td>高权重进程</td>
</tr>
<tr>
<td>BACKUP_APP_ADJ</td>
<td>3</td>
<td>正在备份的进程</td>
</tr>
<tr>
<td><strong>PERCEPTIBLE_APP_ADJ</strong></td>
<td>2</td>
<td>可感知的进程，比如那种播放音乐</td>
</tr>
<tr>
<td><strong>VISIBLE_APP_ADJ</strong></td>
<td>1</td>
<td>可见进程</td>
</tr>
<tr>
<td><strong>FOREGROUND_APP_ADJ</strong></td>
<td>0</td>
<td>前台进程</td>
</tr>
<tr>
<td>PERSISTENT_SERVICE_ADJ</td>
<td>-11</td>
<td>重要进程</td>
</tr>
<tr>
<td>PERSISTENT_PROC_ADJ</td>
<td>-12</td>
<td>核心进程</td>
</tr>
<tr>
<td>SYSTEM_ADJ</td>
<td>-16</td>
<td>系统进程</td>
</tr>
<tr>
<td>NATIVE_ADJ</td>
<td>-17</td>
<td>系统起的Native进程</td>
</tr>
</tbody>
</table>
<p>oom_adj的值越小，进程的优先级越高，普通进程oom_adj值是大于等于0的，而系统进程oom_adj的值是小于0的，第三方应用一般只能干掉4以上的进程。我们可以通过<strong>ps|grep</strong>和<strong>cat /proc/process id/oom_adj</strong>查看当前进程的oom_adj值。</p>
<h1 id="常见的几种保活方案"><a href="#常见的几种保活方案" class="headerlink" title="常见的几种保活方案"></a>常见的几种保活方案</h1><h2 id="防止被杀死"><a href="#防止被杀死" class="headerlink" title="防止被杀死"></a>防止被杀死</h2><ul>
<li><p>降低oom_adj的值，提高进程优先级，减少内存占用。<br>如锁屏时候进程中开启一个像素的透明Activity，这样进程变为前台进程防止被杀死。</p>
</li>
<li><p>前台服务，使用Android的一个通知栏的bug，调用startForegound发送一个空的notification，在通知栏没有任何通知，而且进程同样处于低oom_adj状态。4.3以后通过开两个service绑定到同一个通知ID，然后干掉其中一个移除通知显示，保留前台服务（Android7.1修复了这个漏洞）。</p>
</li>
</ul>
<ul>
<li>业务多进程实现，保持单进程最小内存占用，增大存活几率。目前主流应用大多采用多进程的方式</li>
</ul>
<h2 id="如何拉活"><a href="#如何拉活" class="headerlink" title="如何拉活"></a>如何拉活</h2><p><strong>1、利用系统广播拉活（ 开机、网络变化、文件挂载等）</strong></p>
<blockquote>
<p>缺点：可能被安全软件禁用，不可控，不能保证立即拉活（程序被强制干掉，不会接收到广播）。同时,Android N删除了三项隐式广播，后续不排除会删除其他系统广播，所以在开发过程中应该减少对系统广播的依赖。</p>
<p>解决：第三方相互唤醒，很多大厂都采用该方案。</p>
</blockquote>
<p><strong>2、利用系统service机制拉活。</strong><br>onStartCommand方法必须具有一个整形的返回（START_STICKY），这个整形的返回值用来告诉系统在服务启动完毕后，被杀死后对应的操作。也可以在onDestroy方法中重建。</p>
<blockquote>
<p>缺点：<br>1、内存不足，回收后，尝试重新创建。<br>2、多次kill后不会拉活。<br>3、强制kill后 不会重启</p>
</blockquote>
<p><strong>3、进程守护。</strong><br>利用native进程拉活（5.0后不可靠，主进程和子进程一起杀死）</p>
<ul>
<li>fork新进程进行守护，轮训定时器判断</li>
<li>主进程中创建监控并持有文件锁，新进程中申请文件锁被阻塞 ，获得锁则拉活.</li>
</ul>
<blockquote>
<p>解决：可以想办法让子进程脱离主进程所属进程组，切断联系。<a href="http://blog.csdn.net/yyh352091626/article/details/50542554" target="_blank" rel="external">http://blog.csdn.net/yyh352091626/article/details/50542554</a></p>
</blockquote>
<p><strong>4、JobSheduler机制拉活（5.0后的替代方案）</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上几种保活方案并不是完全可靠，只能降低被杀死的概率。系统有自己特定的进程管理方式，官方不推荐使用各类保活手段，除非强烈的产品需求，各种利用系统漏洞的保活方案一定要慎用，保活会产生一些性能和电量的消耗，甚至引发不可预知的风险。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/05/Android系统下编译模式的演变/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/05/Android系统下编译模式的演变/" itemprop="url">
                  Android系统下编译模式的演变
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-05T09:28:18+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java的执行方式"><a href="#Java的执行方式" class="headerlink" title="Java的执行方式"></a>Java的执行方式</h1><p>Java虚拟机有3种执行方式，分别是解释执行、编译执行和混合模式，默认情况下处于混合模式中。使用命令行java –version可以查看虚拟机的执行模式。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/Java%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F.jpg" alt="Java编译模式"></p>
<ul>
<li><p>interpreted mode表示解释执行模式，全部代码均解释执行。</p>
</li>
<li><p>compiled mode表示编译执行模式，和解释执行模式相反，对于所有的方法，无论是否是热点代码，都会被编译执行。</p>
</li>
<li><p>mixed mode表示混合模式，部分代码会被解释执行，也可能被编译执行。虚拟机决定热点（高频、反复使用）代码是否需要编译执行。</p>
</li>
</ul>
<h1 id="什么是JIT和AOT"><a href="#什么是JIT和AOT" class="headerlink" title="什么是JIT和AOT"></a>什么是JIT和AOT</h1><h2 id="JIT（Just-in-time）"><a href="#JIT（Just-in-time）" class="headerlink" title="JIT（Just-in-time）"></a>JIT（Just-in-time）</h2><p>JIT属于动态编译编译器，通常也被称为即时编译器。Java虚拟机默认使用的编译技术，也就是前面提到的混合编译模式，相比于解释执行全部字节码的效率低下，编译执行不加区分的编译转化成机器码。而混合模式较好的结合了二者的优势，对部分热点代码进行编译优化，在执行效率上接近C/C++。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/jit%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.jpg" alt="jit工作过程"></p>
<p>从图中看出整个执行过程如下：</p>
<p>1、源代码经javac编译成字节码，即class文件</p>
<p>2、字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等）</p>
<p>3、如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码</p>
<p>4、如否，则直接由解释器解释执行</p>
<p>5、操作系统及类库调用</p>
<p>6、硬件</p>
<blockquote>
<p>运行时会将JIT编译过的机器码保存起来，第二次直接执行，但是识别热点代码也需要一个准备的过程。同时，对于部分只会被执行一次的代码，编译就是浪费效率。</p>
</blockquote>
<h2 id="AOT（Ahead-of-time）"><a href="#AOT（Ahead-of-time）" class="headerlink" title="AOT（Ahead-of-time）"></a>AOT（Ahead-of-time）</h2><p>AOT，就是在程序运行之前先将代码编译成本地机器语言的程序。AOT本质上是一种静态编译，它是相对于JIT而言的，也就是说，前者是在程序运行前进行编译，而后者是在程序运行时进行编译。</p>
<blockquote>
<p>静态编译可以在运行时执行最大数量的本地代码，无需占用运行时间。但是编译方法越多，代码占用的内存也越多，大量代码可能很少甚至不会执行，编译器也无法对代码结构做优化。</p>
</blockquote>
<h1 id="Android系统上的演变"><a href="#Android系统上的演变" class="headerlink" title="Android系统上的演变"></a>Android系统上的演变</h1><p>早期Android的Dalvik虚拟机在架构上保持跟JVM高度相似，如图：</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8C%BA%E5%88%AB.jpg" alt="虚拟机区别"></p>
<ul>
<li>JNI_GetDefaultJavaVMInitArgs  –获取虚拟机的默认初始化参数</li>
<li>JNI_CreateJavaVM  – 在进程中创建虚拟机实例</li>
<li>JNI_GetCreatedJavaVMs – 获取进程中创建的虚拟机实例</li>
</ul>
<p>从最早期的解释执行到现在的混合编译，经历了多个阶段：</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/Android%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC.jpg" alt="Android系统版本"></p>
<p>尤其是在4.4之后，性能上有了较大提升。引入ART取代了Dalvik。ART的主要特征之一就是安装时对应用的AOT编译。优点是优化产生的本地代码性能更好，执行起来需要更少的电量。劣势在于安装文件所需的空间和时间。在5.0和6.0中，大的应用需要数分钟才能安装完。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/AOT%20JIT%E5%AF%B9%E6%AF%94.jpg" alt="AOT JIT对比"></p>
<p>保持dex的向下兼容<br><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8E%A5%E5%8F%A3.jpg" alt="接口不变"></p>
<p>7.0时代，ART中有一种新的、更快的解释器，通过一种新的JIT完成，但是这种JIT的信息不是持久化的。取而代之的是，代码在执行期间被分析，分析结果保存起来。然后，当设备空转和充电的时候，ART会执行针对“热代码”进行的基于分析的编译和优化。这个过程也属于AOT，可以理解为全时段的编译（All-Of-the-Time compilation）<br><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/%E6%B7%B7%E5%90%88%E8%BF%90%E8%A1%8C%E6%97%B61.png" alt="混合运行时1"></p>
<p>工作流程：</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/AndroidCompileMode/%E6%B7%B7%E5%90%88%E8%BF%90%E8%A1%8C%E6%97%B62.jpg" alt="混合运行时2"></p>
<blockquote>
<p>系统会收集使用代码的各种信息（用户使用习惯），存储在profiles文件夹，当收集到一定量之后，达到系统的触发条件，进行dex2oat编译成机器码直接执行。这个过程不是一次性的，而是可以进行多次的，随着收集到应用运行时的代码各种信息越多，那么代码编译的质量就越高，效率越高，能不断更新编译的机器语言，达到执行最优化。</p>
</blockquote>
<p>混合使用AOT、解释、JIT的策略，优点也很明显：</p>
<ul>
<li>应用安装时间大大缩短</li>
<li>无需要优化，系统升级更快</li>
<li>应用的内存占用更小</li>
<li>改善了性能、更低的电池消耗</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>混合模式也不是全能，达到最佳性能同样需要一个时间过程。没有万能的方案，每种模式都有其自身的优缺点，Android也是根据系统生态、硬件水平等方面的因素做出权衡。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/12/InputMethodManger导致的内存泄漏问题/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/12/InputMethodManger导致的内存泄漏问题/" itemprop="url">
                  InputMethodManger导致的内存泄漏问题
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-12T20:33:08+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>今天使用LeakCanary检查程序，发现很多页面都存在内存泄漏，虽然各页面的引用路径不完全相同，但最终都会指向InputMethodManager，所以考虑从InputMethodManager入手。如图：<br><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/leak/leak.png" alt="leak"><br>查看代码没有发现什么问题，于是看了一下InputMethodManager的源码,下面是获取sInstance的方法</p>
<pre><code>public static InputMethodManager getInstance() {
    synchronized (InputMethodManager.class) {
        if (sInstance == null) {
            IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);
            IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);
            sInstance = new InputMethodManager(service, Looper.getMainLooper());
        }
        return sInstance;
    }
}
</code></pre><ul>
<li>sInstance是一个全局单例，多个页面使用同一个InputMethodManager实例，也就是说sInstance的引用链指向新页面时，老的页面才能回收释放。</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>思路：</strong></p>
<p>1、定位InputMethodManager中具体的引用变量；</p>
<p>2、页面onDestroy时给其置空（使用反射）。</p>
<p>解决这个问题需要复现并结合源码进行分析，同时使用反射不免会产生一些新的bug，网上搜索看看是否有成熟的解决方案。</p>
<p>其实这是Android的一个公开bug  <a href="https://issuetracker.google.com/issues/37043700" target="_blank" rel="external">链接</a></p>
<p><strong>看如下描述</strong>：</p>
<p>InputMethodManager.mServedView keeps a reference to that last focused view, until another view get focus. This prevent the part of the view hierarchy that was detached from being garbage collected, and therefore creates a memory leak. </p>
<p>原来问题在mServedView这个变量上，它指向的就是获取焦点用于输入的view，同时这个view又持有了页面的引用。</p>
<p>贴出大神的解决方案 <a href="https://gist.github.com/pyricau/4df64341cc978a7de414" target="_blank" rel="external">链接</a>：</p>
<pre><code>public class IMMLeaksUtils {

/**
 * Fix for https://code.google.com/p/android/issues/detail?id=171190 .
 *
 * When a view that has focus gets detached, we wait for the main thread to be idle and then
 * check if the InputMethodManager is leaking a view. If yes, we tell it that the decor view got
 * focus, which is what happens if you press home and come back from recent apps. This replaces
 * the reference to the detached view with a reference to the decor view.
 *
 * Should be called from {@link Activity#onCreate(android.os.Bundle)} )}.
 */
public static InputMethodManager getInputMethodManager(Application application) {
    final InputMethodManager inputMethodManager =
            (InputMethodManager) application.getSystemService(INPUT_METHOD_SERVICE);

    if (SDK_INT &lt; KITKAT || SDK_INT &gt; 23) {
        return inputMethodManager;
    }

    final Field mServedViewField;
    final Field mHField;
    final Method finishInputLockedMethod;
    final Method focusInMethod;
    try {
        mServedViewField = InputMethodManager.class.getDeclaredField(&quot;mServedView&quot;);
        mServedViewField.setAccessible(true);
        mHField = InputMethodManager.class.getDeclaredField(&quot;mH&quot;);//lock
        mHField.setAccessible(true);
        finishInputLockedMethod = InputMethodManager.class.getDeclaredMethod(&quot;finishInputLocked&quot;);
        finishInputLockedMethod.setAccessible(true);
        focusInMethod = InputMethodManager.class.getDeclaredMethod(&quot;focusIn&quot;, View.class);
        focusInMethod.setAccessible(true);
    } catch (NoSuchMethodException | NoSuchFieldException unexpected) {
        Log.e(&quot;IMMLeaks&quot;, &quot;Unexpected reflection exception&quot;, unexpected);
        return inputMethodManager;
    }

    application.registerActivityLifecycleCallbacks(new LifecycleCallbacksAdapter() {
        @Override
        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
            ReferenceCleaner cleaner =
                    new ReferenceCleaner(inputMethodManager, mHField, mServedViewField, finishInputLockedMethod);
            View rootView = activity.getWindow().getDecorView().getRootView();
            ViewTreeObserver viewTreeObserver = rootView.getViewTreeObserver();
            viewTreeObserver.addOnGlobalFocusChangeListener(cleaner);
        }
    });

    return inputMethodManager;
}

/** Helper to avoid implementing all lifecycle callback methods. */
static class LifecycleCallbacksAdapter implements Application.ActivityLifecycleCallbacks {
    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {

    }

    @Override
    public void onActivityStarted(Activity activity) {

    }

    @Override
    public void onActivityResumed(Activity activity) {

    }

    @Override
    public void onActivityPaused(Activity activity) {

    }

    @Override
    public void onActivityStopped(Activity activity) {

    }

    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {

    }

    @Override
    public void onActivityDestroyed(Activity activity) {

    }
}

static class ReferenceCleaner implements MessageQueue.IdleHandler, View.OnAttachStateChangeListener,
        ViewTreeObserver.OnGlobalFocusChangeListener {

    private final InputMethodManager inputMethodManager;
    private final Field mHField;
    private final Field mServedViewField;
    private final Method finishInputLockedMethod;

    ReferenceCleaner(InputMethodManager inputMethodManager, Field mHField, Field mServedViewField,
            Method finishInputLockedMethod) {
        this.inputMethodManager = inputMethodManager;
        this.mHField = mHField;
        this.mServedViewField = mServedViewField;
        this.finishInputLockedMethod = finishInputLockedMethod;
    }

    @Override
    public void onGlobalFocusChanged(View oldFocus, View newFocus) {
        if (newFocus == null) {
            return;
        }
        if (oldFocus != null) {
            oldFocus.removeOnAttachStateChangeListener(this);
        }
        Looper.myQueue().removeIdleHandler(this);
        newFocus.addOnAttachStateChangeListener(this);
    }

    @Override
    public void onViewAttachedToWindow(View v) {
    }

    @Override
    public void onViewDetachedFromWindow(View v) {
        v.removeOnAttachStateChangeListener(this);
        Looper.myQueue().removeIdleHandler(this);
        Looper.myQueue().addIdleHandler(this);
    }

    @Override
    public boolean queueIdle() {
        clearInputMethodManagerLeak();
        return false;
    }

    private void clearInputMethodManagerLeak() {
        try {
            Object lock = mHField.get(inputMethodManager);
            // This is highly dependent on the InputMethodManager implementation.
            synchronized (lock) {
                View servedView = (View) mServedViewField.get(inputMethodManager);
                if (servedView != null) {

                    boolean servedViewAttached = servedView.getWindowVisibility() != View.GONE;

                    if (servedViewAttached) {
                        // The view held by the IMM was replaced without a global focus change. Let&apos;s make
                        // sure we get notified when that view detaches.

                        // Avoid double registration.
                        servedView.removeOnAttachStateChangeListener(this);
                        servedView.addOnAttachStateChangeListener(this);
                    } else {
                        // servedView is not attached. InputMethodManager is being stupid!
                        Activity activity = extractActivity(servedView.getContext());
                        if (activity == null || activity.getWindow() == null) {
                            // Unlikely case. Let&apos;s finish the input anyways.
                            finishInputLockedMethod.invoke(inputMethodManager);
                        } else {
                            View decorView = activity.getWindow().peekDecorView();
                            boolean windowAttached = decorView.getWindowVisibility() != View.GONE;
                            if (!windowAttached) {
                                finishInputLockedMethod.invoke(inputMethodManager);
                            } else {
                                decorView.requestFocusFromTouch();
                            }
                        }
                    }
                }
            }
        } catch (IllegalAccessException | InvocationTargetException unexpected) {
            Log.e(&quot;IMMLeaks&quot;, &quot;Unexpected reflection exception&quot;, unexpected);
        }
    }

    private Activity extractActivity(Context context) {
        while (true) {
            if (context instanceof Application) {
                return null;
            } else if (context instanceof Activity) {
                return (Activity) context;
            } else if (context instanceof ContextWrapper) {
                Context baseContext = ((ContextWrapper) context).getBaseContext();
                // Prevent Stack Overflow.
                if (baseContext == context) {
                    return null;
                }
                context = baseContext;
            } else {
                return null;
            }
        }
    }
}
}
</code></pre><p>上面对原代码进行了细微的调整。</p>
<p><strong>使用：</strong></p>
<ul>
<li><p>onCreate()中调用IMMLeaksUtils.getInputMethodManager方法获取InputMethodManager对象</p>
</li>
<li><p>只在有文本输入的页面调用</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/01/从Java到Kotlin/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/01/从Java到Kotlin/" itemprop="url">
                  从Java到Kotlin
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-01T19:05:06+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kotlin是什么"><a href="#Kotlin是什么" class="headerlink" title="Kotlin是什么"></a>Kotlin是什么</h1><p>今年Google I/O 大会正式确立了Kotlin的地位，作为一名Android开发者，一定要紧跟Google的步伐。</p>
<p>Kotlin和Java都是基于JVM的编程语言（开源），所生成的字节码高度相似。语法上和Groovy、Javascript都很类似，非常容易上手。——IntelliJ IDEA由JetBrains开发(Android Studio基于它的插件实现) ，Kotlin也是JetBrains创造，所以他们之间存在天然的联系。</p>
<ul>
<li><strong>与Java交互性好</strong></li>
</ul>
<blockquote>
<p>Kotlin和Java的交互性很好，可以说是无缝连接。这表现在Kotlin可以自由的引用Java的代码，反之亦然。</p>
<p>Kotlin可以现有的全部的Java框架和库Java文件可以很轻松的借助IntelliJ的插件转成Kotlin</p>
</blockquote>
<ul>
<li><strong>Kotlin应用广泛</strong></li>
</ul>
<blockquote>
<p>Kotlin具有跨平台性，可以用于服务器端、Android和JavaScript </p>
<p>在Android应用开发上有着较好的支持，存在Dagger，RxKotlin,Anko等等工具库。目前一些大厂以及开源项目已经使用Kotlin，Java转Kotlin在不久的将来就会全面展开。</p>
</blockquote>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><p><strong>1、语法上(不讲具体的语法，特性)</strong></p>
<pre><code>//variables and constants
var currentVersionCode = 1   //变量当前的版本号，类型Int可以根据值推断出来
var currentVersionName : String = &quot;1.0&quot; //显式标明类型
val APPNAME = &quot;droidyue.com&quot; //常量APPNAME 类型(String)可以根据值推断出来

//methods
fun main(args: Array&lt;String&gt;) {
    println(args)
}

// class
class MainActivity : AppCompatActivity() {

}
</code></pre><ul>
<li>Kotlin支持智能类型转换。</li>
<li>另外用var表示变量，val表示常量更加的简洁</li>
<li>方法也很简单（使用fun缩写标识方法）</li>
<li>类的继承和实现很简单，使用:即可</li>
<li>Kotlin每个句子都不需要加分号;</li>
</ul>
<p><strong>2、简化代码，代码量大大减少。</strong></p>
<p>Java</p>
<pre><code>public class User {
    private String name;
    private String id;

    public User(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}
</code></pre><p>Kotlin </p>
<pre><code>data class User(var name: String, var id: String)
</code></pre><p> Kotlin 就会创建出一个完整的数据类，并自动生成相应的 equals、hashcode、toString 方法</p>
<p><strong>3、便于扩展，现有类的基础上，添加一些属性或者方法，无需继承。</strong></p>
<p>Java</p>
<pre><code>Button button = findviewbyid(R.id.button)
button.setOnClickListener(new View.OnClickListener() {
    @Override public void onClick(View v) {
        Toast.makeText(this,&quot;hello java&quot;,Toast.LENGTH_SHORT);
    }
});
</code></pre><p>Kotlin</p>
<pre><code>//支持默认参数值，减少方法重载
fun Context.toast(message: String, duration:Int = Toast.LENGTH_LONG) {
    Toast.makeText(this, message, duration).show()
}

button.setOnClickListener {toast(&quot;hello kotlin&quot;)}
</code></pre><p><strong>4、安全性</strong></p>
<p>Java</p>
<pre><code>public void test(String string) {
    if (string != null) {
        char[] chars = string.toCharArray();
        if (chars.length &gt; 10) {
            System.out.println(((Character)chars[10]).hashCode());
        }
    }
}
</code></pre><p>Kotlin  </p>
<pre><code>fun testNullSafeOperator(string: String?) {
    System.out.println(string?.toCharArray()?.getOrNull(10)?.hashCode())
}
</code></pre><p>Java中不得不写很多防御性的代码，防止出现NullPointerException，Kotlin使用空安全符？来明确对象是否为空，否则编译无法通过。</p>
<h1 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h1><p>Android Studio在3.0版本中直接集成了Kotlin插件，在3.0之下还需手动安装：</p>
<p><strong>1、在Setting里找到Plugin选项，搜索Kotlin插件。</strong></p>
<ul>
<li>Kotlin：基础插件，对Kotlin的语法支持</li>
<li><p>Kotlin Android Extensions：可以自动从XML中注入View到activity中，作为属性直接使用，省去了findViewById()和convert view的过程。</p>
<pre><code>//导入指定布局文件中所有控件属性
import kotlinx.android.synthetic.main.＜布局＞.*
</code></pre><p>  ButterKnife可以扔到垃圾桶了。但存在一个问题，对于历史XML布局文件，ViewID的命名方式可能在Java代码中并不友好。解决办法：</p>
<blockquote>
<p>1、给布局文件中的viewID rename</p>
<p>2、扩展Content类，自定义变量名转换映射方法</p>
<p>3、继续使用findViewById方式。</p>
</blockquote>
</li>
</ul>
<p><strong>2、在模块的gradle下加入如下代码：</strong></p>
<pre><code>apply plugin: &apos;kotlin-android&apos;
apply plugin: &apos;kotlin-android-extensions&apos;
</code></pre><p>   <strong>然后在project的gradle下加入：</strong></p>
<pre><code>classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$yourversion&quot;
</code></pre><p><strong>3、编写Kotlin  or Java代码转换</strong></p>
<p><strong>4、构建和发布用于 Android 的 Kotlin 应用程序</strong></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>1、官方3.0正式版未发布，可能有坑</strong></p>
<p><strong>2、是否带来效率的提高?</strong></p>
<blockquote>
<p>在生成环境中，稳定高于一切。追求新技术，一方面会给团队带来开发和维护上的学习成本，另一方面也要承担未来某些情况下因为对新技术不熟悉而产生未知问题的风险。</p>
<p>在后面的项目中，部分小模块可以选择性使用。Kotlin的优势会慢慢展现出来的，但是需要一个较为漫长的过渡期。</p>
</blockquote>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p>官方网站<br>链接：<a href="http://kotlinlang.org/" target="_blank" rel="external">http://kotlinlang.org/</a></p>
<p>在线代码环境<br>链接：<a href="https://try.kotlinlang.org/" target="_blank" rel="external">https://try.kotlinlang.org/</a> </p>
<p>官方GitHub<br>链接：<a href="https://github.com/JetBrains/kotlin" target="_blank" rel="external">https://github.com/JetBrains/kotlin</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/打造一个通用Adapter/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/28/打造一个通用Adapter/" itemprop="url">
                  打造一个通用Adapter
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T21:33:54+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目通知模块涉及到的通知类型多达三四十种，并且消息列表分散在多个页面。本文使用RecycleView展示多种布局类型，考虑到通知消息格式具有一定的相似性，所以把它做成一个通用Adapter，便于后期的扩展和维护。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Android系统在v7包中提供了一种新的组件RecycleView，通过LayoutManager来实现过去常常使用的ListView和GridView，使用过程中重写RecycleViewAdapter的三个方法：</p>
<blockquote>
<p>1、首先在getItemViewType方法中返回固定的类型标识viewType。ItemView的type类型，由服务端返回的数据Model决定。</p>
<p>2、然后在onCreateViewHolder中根据viewType参数，也就是getItemViewType的返回值来判断需要创建的ViewHolder类型。</p>
<p>3、最后在onBindViewHolder方法中对ViewHolder的具体类型进行判断，分别为不同类型的ViewHolder进行绑定数据与逻辑处理。</p>
</blockquote>
<p>所以Adapter的实现代码如下：</p>
<pre><code>    @Override
public int getItemViewType(int position) {
    if (mNoticesMessageDTOs != null &amp;&amp; position &lt; mNoticesMessageDTOs.size()) {
        return mNoticesMessageDTOs.get(position).getEventType();
    }
}

@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    RecyclerView.ViewHolder viewHolder = null;
    switch (viewType) {
        ......
        case Constants.EventType.FOLDER_CREATE:
        case Constants.EventType.FOLDER_RESTORE:
        case Constants.EventType.FOLDER_DELETE:
            viewHolder = new NoticeCardVHolder(parent, mViewComponent);
            break;
        case Constants.EventType.DISCUSS_NEW_TOPIC:
        case Constants.EventType.DISCUSS_NEW_COMMIT:
        case Constants.EventType.DISCUSS_REPLY_COMMIT:
        case Constants.EventType.DISCUSS_AT_YOU:
            viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
            break;

    }
    return viewHolder;
}

@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
    if (holder instanceof NoticeCardVHolder) {
        ((NoticeCardVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectVHolder) {
        ((NoticeProjectVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectAnounceVHolder) {
        ((NoticeProjectAnounceVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeLabelVHolder) {
        ((NoticeLabelVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectApproveVHolder) {
        ((NoticeProjectApproveVHolder) holder).render(mNoticesMessageDTOs.get(position));
    }
}

@Override
public int getItemCount() {
    return mNoticesMessageDTOs.size();
}
</code></pre><p>很明显看出，这种实现方式存在如下缺陷：</p>
<p>1、类型检查与转换方式低效。由于在onCreateViewHolder中根据不同类型创建了不同的ViewHolder，所以onBindViewHolder方法需要针对不同类型的ViewHolder进行数据绑定与逻辑处理。</p>
<p>2、不利于扩展和维护。数据源是从服务端获取，当需求发生变化，比如新增其他通知类型，或者Model数据结构发生变化时，需要重写以上三个方法。随着类型的逐渐增多，Adapter会越来越臃肿，变得难以维护。</p>
<p>3、代码的重复实现。每种类型的ViewHolder单独实现事件点击、设置已读样式等。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>针对前文所提到的三点问题，从getItemViewType、onCreateViewHolder、onBindViewHolder这三个方法入手，提出以下解决思路：</p>
<p><strong>1、实现BaseViewHolder。</strong>从不同ViewHolder中抽象出相似的功能，比如点击跳转，设置已读样式，头像的显示规则等，避免重复实现。在继承RecyclerView.ViewHolder的基础上派生出BaseViewHolder，所有ViewHolder必须继承BaseViewHolder，并在此基础上扩展。</p>
<pre><code>abstract public class BaseVHolder extends RecyclerView.ViewHolder {

    public BaseVHolder(View itemView, ViewComponent component) {
        super(itemView);
        if (component != null) {
            component.inject(this);
        }
    }

    public void render(NoticesMessageDTO noticesMessageDTO) {

    }

    protected void modifyLayout() {
      ......
    }

    public CharSequence renderSpan(String text, String color, boolean isBold, boolean isDelete) {
       ......
    }

    public void setUserImage(SimpleDraweeView mUserAvator, NoticesMessageDTO.ContentObj contentObj) {
        ......
    }

    public void parseDeleteLine(SpannableStringBuilder operateStr) {
        ......
    }

    //页面路由统一处理跳转事件
    public void setOnNoticesItemClickListener(final NoticesMessageDTO noticesMessageDTO) {
        ......
    }

    //设置item为已读样式
    protected void setItemReaded() {
            ......
    }

}
</code></pre><p><strong>2、合并ViewHolder。</strong>将所有通知类型（服务端控制）按视觉样式分为五个大类，并创建五种不同的itemView，然后根据viewType实现五种ViewHolder。如下是卡片相关通知类型。</p>
<pre><code>public class NoticeCardVHolder extends BaseVHolder {
    @BindView(R.id.tv_user_name)
    TextView mUserName;
    @BindView(R.id.project_name)
    TextView mProjectName;
    @BindView(operate)
    TextView mOperate;
    @BindView(R.id.user_avator)
    SimpleDraweeView mUserAvator;
    @BindView(R.id.date)
    TextView mDate;

    public NoticeCardVHolder(ViewGroup parent, ViewComponent component) {
        super(LayoutInflater.from(parent.getContext()).inflate(R.layout.notice_card_view_holder, parent, false),
                component);
        ButterKnife.bind(this, itemView);
    }

    public void render(NoticesMessageDTO noticesMessageDTO) {
        ......
    }

    //文案拼接
    private void renderOperateView(NoticesMessageDTO.ContentObj contentObj, int readYn) {
        ......
    }

        protected void setItemReaded() {
        ......
    }
}
</code></pre><p><strong>3、BaseViewHolder作为onCreateViewHolder方法的返回值类型。</strong><br>BaseViewHolder作为ViewHolder的基类，可避免在onBindViewHolder中对ViewHolder进行类型检查与类型转换，简化了onBindViewHolder方法中的数据绑定与逻辑处理。</p>
<p>按以上实现思路，getItemViewType 、onCreateViewHolder和onBindViewHolder方法的代码将变得相对简单。如下</p>
<pre><code>@Override
public int getItemViewType(int position) {
    if (mNoticesMessageDTOs != null &amp;&amp; position &lt; mNoticesMessageDTOs.size()) {
        return mNoticesMessageDTOs.get(position).getEventType();
    }
}

public BaseVHolder onCreateViewHolder(ViewGroup parent, int viewType) { 
    BaseVHolder viewHolder = null;
    switch (viewType) {
            ......    
        case Constants.EventType.CARD_DELTE:
        case Constants.EventType.CARD_RESTORE:
        case Constants.EventType.CARD_MOVE:
        case Constants.EventType.CARD_RENAME:
            viewHolder = new NoticeCardVHolder(parent, mViewComponent);
            break;
        case Constants.EventType.DISCUSS_NEW_TOPIC:
        case Constants.EventType.DISCUSS_NEW_COMMIT:
        case Constants.EventType.DISCUSS_REPLY_COMMIT:
        case Constants.EventType.DISCUSS_AT_YOU:
            viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
            break;
        default:
            viewHolder = null;
            break;
    }
    return viewHolder;
}

@Override
public void onBindViewHolder(BaseVHolder holder, int position) {
    holder.render(mNoticesMessageDTOs.get(position));
} 
</code></pre><p>在onBindViewHolder中不需要对ViewHolder进行任何操作，数据的绑定和逻辑处理都交给对应的ViewHolder来处理，因此每个ViewHolder可根据实际情况实现render方法。这样所有的业务逻辑全部放在ViewHolder中，如果新增一种类型只需实现对应的ViewHolder，然后在onCreateViewHolder方法中创建ViewHolder类型即可，这样Adapter会便于扩展和维护。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>前面实现的Adapter只能处理通知相关类型，算不上真正的通用。如果应用场景发生变化，比如项目列表、文件记录或搜索结果列表等，此时所绑定的数据Model不再是通知类型，Adapter将无法适应这些情况。因此做了如下改造：</p>
<p><strong>1、定义通用的viewType类型。</strong></p>
<pre><code>/** 定义不同vholder类型 **/
public interface VHolderType {
    /** 通知相关 */
    int NoticeProjectAnounce = 101;
    int NoticeProjectApprove = 102;
    int NoticeProject = 103;
    int NoticeCard = 104;
    int NoticeLabel = 105;
    /** 搜索相关 **/
    int SearchCardHead = 201;
    int SearchCard = 202;
    int SearchFile = 203;
    int SearchFolder = 204;
    /** 项目相关 **/
    int ShowProject = 301;
}
</code></pre><p><strong>2、数据Model中增加type标识。</strong>前面介绍的viewType是由服务端控制，这里为兼容不同的数据Model，需要在本地统一配置管理，然后根据Model获得自定义viewType。</p>
<ul>
<li><p><strong>定义抽象接口</strong></p>
<pre><code>public interface TypeFactory {
    int type(NoticesMessageDTO noticesMessageDTO);
    int type(SearchResourceDTO searchResourceDTO);
    int type(ProjectInfoDTO projectInfoDTO);
}

//列表相关Model需实现该接口
public interface ViewModel {
    int type(TypeFactory typeFactory);
}
</code></pre></li>
</ul>
<ul>
<li><strong>实现ViewModel接口。</strong>不同类型的Model以List\<viewmodel\> 的形式放在列表中。</viewmodel\></li>
</ul>
<pre><code>public class SearchResourceDTO implements MessagesAdapter.ViewModel{
    ......
    @Override
    public int type(MessagesAdapter.TypeFactory typeFactory) {
        return  typeFactory.type(this);
    }
}

public class NoticesMessageDTO implements MessagesAdapter.ViewModel{
    ......
    @Override
    public int type(MessagesAdapter.TypeFactory typeFactory) {
        return typeFactory.type(this);
    }
}
</code></pre><p><strong>3、配置TypeFactory，将Model数据转化为通用viewType。</strong></p>
<pre><code>public static class TypeFactoryForList implements TypeFactory {
    @Override
    public int type(NoticesMessageDTO noticesMessageDTO) {
        int viewType = 0;
        if (noticesMessageDTO != null) {
            switch (noticesMessageDTO.getEventType()) {
                   ......

                case Constants.EventType.PROJECT_MODIFY_NOTICE: // 公告
                    viewType = Constants.VHolderType.NoticeProjectAnounce;
                    break;
                case Constants.EventType.PROJECT_MODIFY_NAME: // 项目信息更新1003
                    viewType = Constants.VHolderType.NoticeProject;
                    break;
                Constants.EventType.CARD_FOLLOW_CANCEL:
                case Constants.EventType.CARD_ADD_FOLLOW:
                case Constants.EventType.CARD_REMOVE_FOLLOW:
                case Constants.EventType.FILE_UPLOAD: // 文件
                case Constants.EventType.FILE_UPDATE:
                case Constants.EventType.FILE_DELETE:
                case Constants.EventType.FILE_RESTORE:
                Constants.EventType.FOLDER_UPLOAD: // 文件夹
                case Constants.EventType.FOLDER_CREATE:
                case Constants.EventType.FOLDER_RESTORE:
                case Constants.EventType.FOLDER_DELETE:
                    viewType = Constants.VHolderType.NoticeCard;
                    break;
                //讨论标注相关
                case Constants.EventType.DISCUSS_NEW_TOPIC:
                case Constants.EventType.DISCUSS_NEW_COMMIT:
                case Constants.EventType.DISCUSS_REPLY_COMMIT:
                case Constants.EventType.DISCUSS_AT_YOU:
                    viewType = Constants.VHolderType.NoticeLabel;
                    break;
            }
        }
        return viewType;
    }

    public int type(SearchResourceDTO searchResourceDTO) {
        int viewType = 0;
        if (searchResourceDTO != null) {
            switch (searchResourceDTO.getResType()) {
                case Constants.SearchResultType.RES_CARD_HEAD:
                    viewType = Constants.VHolderType.SearchCardHead;
                    break;
                case Constants.SearchResultType.RES_CARD:
                    viewType = Constants.VHolderType.SearchCard;
                    break;
                case Constants.SearchResultType.RES_FILE:
                    viewType = Constants.VHolderType.SearchFile;
                    break;
                case Constants.SearchResultType.RES_FOLDER:
                    viewType = Constants.VHolderType.SearchFolder;
            }
        }
        return viewType;
    }

    public int type(ProjectInfoDTO projectInfoDTO) {
        return Constants.VHolderType.ShowProject;
    }
}
</code></pre><p>将类型判断抽取到TypeFactoryForList中，减轻了onCreateViewHolder方法的代码量，同时便于对各种类型进行统一管理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过改进后的Adapter代码如下：</p>
<pre><code>public class MessagesAdapter extends RecyclerView.Adapter&lt;BaseVHolder&gt; {
    private List&lt;ViewModel&gt; mMessageDTOs;

    private ViewComponent mViewComponent;

    public MessagesAdapter(ViewComponent component) {
        mViewComponent = component;
        mMessageDTOs = new ArrayList&lt;ViewModel&gt;();
    }

    @Override
    public int getItemViewType(int position) {
        return mMessageDTOs.get(position).type(new TypeFactoryForList());
    }

    @Override
    public BaseVHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        BaseVHolder viewHolder = null;
        switch (viewType) {
            ......
            case Constants.VHolderType.NoticeProjectAnounce: 
                viewHolder = new NoticeProjectAnounceVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeProjectApprove:
                viewHolder = new NoticeProjectApproveVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeProject:
                viewHolder = new NoticeProjectVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeCard:
                viewHolder = new NoticeCardVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeLabel:
                viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
                break;
        }
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(BaseVHolder holder, int position) {
        holder.render(mMessageDTOs.get(position));
    }
     ......
}
</code></pre><p>将原本应该在Adapter中实现的代码抽离出来，让Adapter更加简洁，更多的逻辑放在ViewHolder和TypeFactory中，数据列表的Item更加独立，甚至可以让不同Model数据混合显示。具有较强的通用性，<br>能够实现列表页面的快速复制。<br>但是还存在一些不足，比如BaseViewHolder中的render方法可能还需要扩展，才能更好的满足多Model情况下的数据绑定与逻辑处理，大家可以根据实际情况进行修改。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" target="_blank" rel="external">https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html</a></p>
<p><a href="http://www.jianshu.com/p/c6a44e18badb" target="_blank" rel="external">http://www.jianshu.com/p/c6a44e18badb</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/16/代码规范检查/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/16/代码规范检查/" itemprop="url">
                  代码规范检查
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-16T19:03:56+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了保证团队内部代码风格的统一，提升代码的质量，更好的遵循标准的编写规范。必须定义一个统一的规范，在执行上前期主要由团队的老司机进行codereview，并对review出来的问题进行总结和回顾，避免后期犯类似的错误。但是这样会加大老司机的工作量，降低整个团队的工作效率，如果项目周期比较赶可能会放松对代码的要求。因此，有必要引入自动化工具来帮助我们保证代码的质量，这里主要采用两种办法：</p>
<ul>
<li><p><strong>coding阶段</strong>：为IDE配置统一的格式化模板，在完成开发后手动进行format。具体配置方式参见<a href="http://note.youdao.com/groupshare/?token=A0EFFF04E19246089EAFACD7A818FEF0&amp;gid=30539562" target="_blank" rel="external">Android端Code Style统一规范</a></p>
</li>
<li><p><strong>build阶段</strong>：使用checkstyle工具检查代码，注释、命名规范、方法长度、空格缩进等不再需要手工检查，由于标准的check过于严格，可以根据实际情况取消部分检查规则。对于不符合规范的代码，警告或者错误提示。</p>
</li>
</ul>
<h1 id="Checkstyle配置"><a href="#Checkstyle配置" class="headerlink" title="Checkstyle配置"></a>Checkstyle配置</h1><p>具体的配置步骤：</p>
<p>1、将自定义的checkstyle.xml文件放在项目/setting目录下.</p>
<p>2、添加checkstyle任务，并配置检查项目。</p>
<pre><code>allprojects{
   repositories{ 
         jcenter()
 }
 task checkstyle(type: Checkstyle) {
       showViolations = true
       configFile file(&quot;../settings/checkstyle.xml&quot;)
       source &apos;src/main/java&apos;//检查Java代码
       include &apos;**/*.java&apos;  //不检查
       exclude &apos;**/gen/**&apos;
       exclude &apos;**/R.java&apos;
       exclude &apos;**/BuildConfig.java&apos;

       // empty classpath
       classpath = files()
       ignoreFailures true     // 忽略检查失败的情况，避免gradle命令执行中止
   }
}
</code></pre><p>3、在module的build.gradle中添加checkstyle插件，并声明checkstyle任务的执行条件。</p>
<pre><code>apply plugin: &apos;checkstyle&apos;

preBuild.dependsOn(&apos;checkstyle&apos;)
assemble.dependsOn(&apos;lint&apos;)
check.dependsOn(&apos;checkstyle&apos;)
</code></pre><p>4、在终端中执行如下命令，可在/app/build/reports中看到生成的警示报告文件。</p>
<pre><code>./gradlew checkstyle 
</code></pre><h1 id="自定义xml配置文件"><a href="#自定义xml配置文件" class="headerlink" title="自定义xml配置文件"></a>自定义xml配置文件</h1><p>IDE的Code Style Format包括如下几个部分：</p>
<ul>
<li>Tabs and Indents</li>
<li>Spaces</li>
<li>Wrapping and braces</li>
<li>Blank lines</li>
<li>JavaDoc</li>
<li>Arrangement</li>
<li>Imports</li>
<li>Code Generation</li>
</ul>
<p>可以直接在IntelliJ IDEA中勾选设置，然后导出配置文件，共享给团队成员。但它只能对代码的格式进行自动调整，无法检查代码的问题和错误。Checkstyle插件是在format的基础上，对代码的格式和语法进行检查和分析，包括下面几大类型：</p>
<ul>
<li>Javadoc Comments </li>
<li>Naming Conventions</li>
<li>Imports</li>
<li>Size Violations</li>
<li>Whitespace</li>
<li>ModifierOrder</li>
<li>Block Checks</li>
<li>Coding</li>
<li>Class Design</li>
<li>Duplicate Code</li>
<li>Miscellaneous</li>
</ul>
<p>根据项目实际情况，主要对Javadoc注释、命名规范、import语句、代码块、缩进和空行以及风格、类设计、重复代码等分析规则进行配置。<br>具体配置文件如下<a href="https://github.com/checkstyle/checkstyle/blob/master/config/checkstyle_checks.xml" target="_blank" rel="external">checkstyle.xml</a></p>
<blockquote>
<p>这里参照了官方提供的配置文件<a href="https://github.com/checkstyle/checkstyle/blob/master/config/checkstyle_checks.xml" target="_blank" rel="external">checkstyle_checks.xml</a>，并加以详细的注释，可根据实际需求添加或移除module。</p>
</blockquote>
<h1 id="自定义文件说明"><a href="#自定义文件说明" class="headerlink" title="自定义文件说明"></a>自定义文件说明</h1><p>Checkstyle配置文件通过指定modules应用到java文件。modules是树状结构，以一个名为Checker的module作为root节点，一般的checker都会包括TreeWalker子module。</p>
<blockquote>
<p>xml配置文件中通过module的name属性来区分module，module的Properties可以控制如何去执行这个module，每个property都有一个默认值，所有的check都有一个severity属性，用它来指定check的level。TreeWalker为每个java文件创建一个语法树，在节点之间调用submodules的Checks。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpeg"
               alt="潘威" />
          <p class="site-author-name" itemprop="name">潘威</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潘威</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>

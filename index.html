<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="个人笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 个人笔记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">个人笔记</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description"></h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/19/如何优雅的写单元测试/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/19/如何优雅的写单元测试/" itemprop="url">
                  如何优雅的写单元测试
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-19T20:54:56+08:00">
                2018-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>越来越多的项目开始尝试写单元测试，关于单元测试的好处以及原理已经有很多资料了，这里不在做过多的讲述，本文主要介绍单元测试在模块化应用中的一些思考，以及如何优雅的写单元测试。</p>
<h2 id="易于测试的代码"><a href="#易于测试的代码" class="headerlink" title="易于测试的代码"></a>易于测试的代码</h2><p>单元测试最大的痛点就是代码耦合，比如直接持有第三方库的引用、不合理的跨层调用等等，除此之外，static method、new object、singleton 都是不利于测试的代码方式，<br>这就意味着需要 mock 大量的替身类，增加了测试成本，应该尽量避免，同时使用依赖注入的方式来代替。</p>
<h2 id="如何做好单元测试？"><a href="#如何做好单元测试？" class="headerlink" title="如何做好单元测试？"></a>如何做好单元测试？</h2><p>首先，在模块化应用中应该创建公共的单元测试模块，里面可以放一些公共的 BaseTest、Shadow Class、Utils、Junit rules 等等，在业务模块中直接 dependency 进来即可，提高写单元测试的效率。</p>
<p>其次，明确需要测试的代码。刚开始的时候，可以只测中间逻辑层和工具类，这部分代码相对“干净”，易于测试，也是逻辑分支最集中的地方。</p>
<p>最后，依赖注入来写单元测试。试想一下 mock 的类都能够自动完成注入，是不是很爽？这样能大大提高编写测试用例的速度，避免重复的 mock 替身类和静态方法，并提高测试代码的可读性。</p>
<p>所以，我们引入了DI框架来做这件事情！</p>
<p><strong>1、开发阶段</strong></p>
<p>我们只需要在一个类似于 dependency 工厂的地方统一生产这些 dependency 对象，以及这些 dependency 的 dependency。所有需要用到这些 dependency 的地方都从这个工厂里面去获取。</p>
<p><strong>2、测试阶段</strong> </p>
<p>定义一个同样的 dependency 工厂，不同的是，该工厂生产的是测试所需要的 Shadow 替身，能够自动识别依赖关系，并实现自动注入！</p>
<h2 id="Dagger2-的应用"><a href="#Dagger2-的应用" class="headerlink" title="Dagger2 的应用"></a>Dagger2 的应用</h2><p>没错！前面提到的 DI 框架就是 Dagger2，为了降低风险并减少使用成本，选择了一个模块进行尝试，Dagger2 既能实现模块内的自动注入，又能向外提供注入能力，实现跨模块的注入。</p>
<p>在 Dagger2 里，生产这些 dependency 的工厂叫做 Module ，然而使用者并不是直接向 Module 要 dependency，而是有一个专门的“工厂管理员”，负责接收使用者的要求，然后到 Module 里面去找到相应的 dependency 对象，最后提供给使用者。这个“工厂管理员”叫做 Component。基本上，这就是 Dagger2 里面最重要的两个概念。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/unitTest/dagger%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="dagger"></p>
<p>上图是 Dagger2 在模块之间的依赖关系，本文只介绍模块内的应用以及单元测试的实现。</p>
<p><strong>1、创建模块级的 LibComponent 和 LibModule</strong></p>
<p>LibModule里面定义了整个模块都要用的dependency，比如PersonalContentInstance  、Scope、 DataSource等等，所以DaggerLibComponent的存在是唯一的，在模块初始化的时候创建好，放在一个地方便于获取。</p>
<pre><code>mInstance.mComponent = DaggerPersonalContentLibComponent.builder()
                .personnalContentLibModule(new PersonnalContentLibModule())
                .build();
</code></pre><p><strong>2、创建 Frame 级别的 FrameComponent 和 FrameModule</strong></p>
<p>FrameModule 里面定义了某个页面用到的 dependency，比如 Context、Handler、Logic、Adapter 等等，每个页面对应一个 DaggerFrameComponent，在页面的 onCreate() 里面创建好。</p>
<p><strong>3、FrameComponent 依赖于 LibComponent</strong> </p>
<p>在 Frame 中可以享受到 LibComponent 中全局依赖的注入，只需要在页面初始化的时候完成注入即可。</p>
<pre><code>DaggerFrameComponent.builder()
    .libComponent(mInstance.getComponent())
    .frameModule(new FrameModule(this))
    .build()
    .injectMembers(this);
</code></pre><p>再看看单元测试里面如何来mock dependency？<br>比如，LearnRecordDetailLogic 会调用mScope 和 mDataSource 中的方法，而 IPersonalContentScope 和 IDataSource 的实例对象是从 Dagger2 的 Component 里面获取的，怎样把 mScope 和 mDataSource 给 mock 掉呢？</p>
<p>实际上，LearnRecordDetailLogic 向 DaggerLibComponent 获取实例调用的是 PersonnalContentLibModule 中的 provideDataSource() 和 provideScope() 方法，最后返回给 LearnRecordDetailLogic ，也就是说，真正实例化  IPersonalContentScope 和 IDataSource 的地方是在 PersonnalContentLibModule。</p>
<pre><code>@Module
public class PersonnalContentLibModule {
    ......

    @PerLibrary
    @Provides
    PersonalContentInstance providePersonalContentInstance() {
        return PersonalContentInstance.getInstance();
    }

    @PerLibrary
    @Provides
    IPersonalContentScope provideScope(PersonalContentInstance instance) {
        return instance.getScope();
    }

    @PerLibrary
    @Provides
    IDataSource provideDataSource(PersonalContentInstance instance) {
        return instance.getDataSourse();
    }
}
</code></pre><p>前面创建 DaggerLibComponent 的时候，给它的 builder 传递了一个 PersonnalContentLibModule 对象，如果我们传给 DaggerLibComponent 的 Module 是一个 TestModule，在它的 provide 方法被调用时，返回一个 mock 的 IPersonalContentScope 和 IDataSource，那么在测试代码中获得的，不就是 mock 后的替身对象吗？</p>
<pre><code>public class PersonnalContentLibTestModule extends PersonnalContentLibModule {
    ......

    @Override
    PersonalContentInstance providePersonalContentInstance() {
        return PowerMockito.mock(PersonalContentInstance.class);
    }

    @Override
    IPersonalContentScope provideScope(PersonalContentInstance instance) {
        return PowerMockito.mock(IPersonalContentScope.class);
    }

    @Override
    IDataSource provideDataSource(PersonalContentInstance instance) {
        return PowerMockito.mock(IDataSource.class);
    }
}
</code></pre><p>以上就是 Dagger2 在单元测试里的应用。在 LibModule 的基础上派生出一个 LibTestModule，除此之外，LearnRecordDetailLogic 还用到了 Context 和 Handler 对象，所以需要创建一个Frame级别的 Module，然后 override 掉 provide方法，让它返回你想要的 mock 对象。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/unitTest/testModule.png" alt="module"></p>
<p>看一下效果，越复杂的类越能发挥出 Dagger2 的威力！</p>
<pre><code>//使用dagger之前
mContext = mock(Context.class);
mHandler = mock(Handler.class);
mDataSource = mock(IDataSource.class);
mScope = mock(IPersonalContentScope.class);
mContentInstance = mock(PersonalContentInstance.class);
when(mContentInstance.getDataSourse()).thenReturn(mDataSource);
when(mContentInstance.getScope()).thenReturn(mScope);
mockStatic(PersonalContentInstance.class);
when(PersonalContentInstance.getInstance()).thenReturn(mContentInstance);


//dagger
DaggerFrameTestComponent.builder()
    .libComponent(ComponentUtil.getLibTestComponent)
    .frameTestModule(new FrameTestModule())
    .build()
    .inject(this);
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Dagger2 在模块内以及单元测试中的应用，DI是一种很好的开发模式，即使不做单元测试，也会让我们的代码更加简洁、干净、解耦，只不过在单元测试中发挥出了更大的威力，让很多难测的代码测试起来更加容易。</p>
<p>最后，介绍一下 Dagger2 的配置方法：</p>
<p>在模块的 build.gradle 中添加</p>
<pre><code>dependencies {
    //other dependencies

    //Dagger2
    compile &quot;com.google.dagger:dagger:${DAGGER_VERSION}&quot;
    annotationProcessor &quot;com.google.dagger:dagger-compiler:${DAGGER_VERSION}&quot;
}
</code></pre><p>正常情况下,main 目录下的源代码 build 后，生成代码放在 /build/generated/source/apt/buildType 下面，但是 test 目录下的测试代码，在 compile-time 阶段却无法识别。查看 build 目录，发现存在这部分代码，但是无法正常 import 进来。所以还需要在 build.gradle 中添加如下代码：</p>
<pre><code>android.libraryVariants.all {
    def aptOutputDir = new File(buildDir, &quot;generated/source/apt/${it.unitTestVariant.dirName}&quot;)
    it.unitTestVariant.addJavaSourceFoldersToModel(aptOutputDir)
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/20/版本号自动管理方案/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/20/版本号自动管理方案/" itemprop="url">
                  版本号自动管理方案
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-20T19:47:56+08:00">
                2018-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一般APP在正式发布前会更新版本信息，就是versionCode和versionName。其中，versionCode是一个int值，随着版本的迭代持续增长，而versionName是一个用户可见的String，起到标识的作用。</p>
<p><strong>每次版本更新都需要修改这两行代码，且手动修改容易出错。</strong></p>
<h1 id="自动获取versionCode"><a href="#自动获取versionCode" class="headerlink" title="自动获取versionCode"></a>自动获取versionCode</h1><p>1、使用 Git 中 commit 的数量来作为版本号</p>
<blockquote>
<p>为了兼容以前的版本，可以加上初始版本值，比如 commitCount+2018031912</p>
</blockquote>
<p>2、取最近一次 commit 的时间戳</p>
<blockquote>
<p>为了兼容，时间格式化为 年月日时</p>
</blockquote>
<p>versionCode 对应 Git 的代码状态，这样可以保证versionCode只增不减。</p>
<blockquote>
<p>注：versionCode最大值为2147483647，可预见时间内肯定够用。</p>
</blockquote>
<h1 id="自动获取versionName"><a href="#自动获取versionName" class="headerlink" title="自动获取versionName"></a>自动获取versionName</h1><p>正常发布完成后，会在master分支打上Tag，那么能否直接利用这个Tag呢？答案是肯定的，比如某个版本Tag值为 v5_6_0，那么 5_6_0 就是有效信息。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/edu/branch_tactics.jpeg" alt="分支管理策略"></p>
<p>我们的发布流程是先上线然后再合回master打Tag，master 打出来还是上个版本的信息。考虑到对外主要是 release 和 hotfix分支,恰恰这两个分支名携带了我们的版本信息。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/edu/branch_info.jpeg" alt="分支信息"></p>
<p>上图可以看出，目前云课堂的分支命名策略完全可以使用脚本自动管理我们的版本号，但是分支命名需要按照特定的格式，也存在人为误差的可能,所以这个作为可选项！(每天会将分支信息推送到群里，错误的命名能够及时发现)</p>
<p>script-git-version.gradle 已经放在壳工程目录下，附上部分代码：</p>
<pre><code>//转成原有的格式
def getAppVersionTime(long time = gitVersionCodeTime) {
    return new Date(1000 * time).format(&quot;yyyyMMddHH&quot;).toInteger()
}

def getAppVersionName(def version = gitBranchName) {
    def pattern = &quot;v(\\d+)(\\_\\d+){2}&quot;
    def matcher = version =~ pattern

    if (matcher.count &gt; 0) {
        version = matcher[0][0].replaceAll(&quot;_&quot;, &quot;.&quot;).replace(&quot;v&quot;, &quot;&quot;)
    } else {
        //防止进入死循环
        if (!version.equals(gitVersionName)) {
            version = getAppVersionName(gitVersionName)
        }
    }
    return version
}
</code></pre><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>在主工程下配置：</p>
<pre><code>apply from: &quot;$rootProject.projectDir/script-git-version.gradle&quot;

android.applicationVariants.all { variant -&gt;
    if (variant.buildType.name.equals(&apos;release&apos;)) {
        variant.mergedFlavor.versionCode = getAppVersionTime()
        variant.mergedFlavor.versionName = getAppVersionName()
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/11/通用网络请求回调接口/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/11/通用网络请求回调接口/" itemprop="url">
                  通用网络请求回调接口
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-11T19:39:56+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>1、上层存在对网络库的直接依赖；</p>
<p>2、success 和 error 回调单独实现，使用上不是很友好，且不利于统一管理</p>
<p>3、网络层保持相对独立，除了通用的异常处理，其他业务逻辑应该交给上层实现</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>1、隔离对网络库的依赖，便于替换网络库</p>
<p>2、封装一个通用请求回调，将服务端返回的错误码和错误信息透传上来，便于上层处理</p>
<p>3、网络层不应该有太多的业务逻辑，不应该持有上层的引用</p>
<h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><p>1、接口友好、稳定、可扩展、易使用</p>
<p>2、不对原来的逻辑造成影响</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>开始有想过实现一个全新的回调接口，直接对 StudyRequestBase 动刀子，但考虑到影响范围广且改动大，故作罢。<br>目前只是对 Response.Listener 和 StudyErrorListenerImp 做了一层封装和转换。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/edu/edu_request_callBack.png" alt="request callback"></p>
<p>StudyRequestListenerImp 实际上提供了onSuccess 和 onError 两种回调方法，同时保留了 StudyErrorListener 中的回调，兼容老的逻辑，且预留了扩展接口，实现对StudyErrorListenerImp逻辑的完整重构。新增一个Toast开关</p>
<p>考虑到当前项目中到处在使用 StudyErrorListenerImp ，避免维护两套逻辑，DefaultStudyRequestListenerImp 类重写了 errorListener() 方法，复用 StudyErrorListenerImp 的异常处理逻辑。</p>
<p>新的回调方法将错误信息透传到上层（主要是服务端返回的 code 和 message），不会对具体的网络库形成依赖，实现对上层的解耦。</p>
<p><strong>如何用?</strong></p>
<p>虽然 StudyRequestListenerImp 和 DefaultStudyRequestListenerImp 达到了同样的效果，但是建议使用 DefaultStudyRequestListenerImp </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    mIdReqOperation = RecomRequestManager.doGetOperationalData(new Response.Listener&lt;GetOperationResult&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void onResponse(GetOperationResult result) &#123;</div><div class="line">            updateRecomChannelPackage(mRecomChannelPackage, result);</div><div class="line">            notifyLoadOperationDataFinish(true, mRecomChannelPackage);</div><div class="line">        &#125;</div><div class="line">    &#125;, new StudyErrorListenerImp(TAG) &#123;</div><div class="line">        @Override</div><div class="line">        public void onErrorResponse(int squence, String url, VolleyError error, boolean showToast) &#123;</div><div class="line">            super.onErrorResponse(squence, url, error, false);</div><div class="line">            notifyLoadOperationDataFinish(false, mRecomChannelPackage);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    ---------------------------------华丽的分割线--------------------</div><div class="line">    //RecomRequestManager.java</div><div class="line">    public static int doGetOperationalData(Response.Listener&lt;GetOperationResult&gt; listener,</div><div class="line">            StudyErrorListener errorListener) &#123;</div><div class="line">        GetOperationDataRequest request = new GetOperationDataRequest(listener, errorListener);</div><div class="line">        return RequestManager.getInstance().postRequest(request);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">```修改后：</div></pre></td></tr></table></figure>
<pre><code>mIdReqOperation = RecomRequestManager.doGetOperationalData(new DefaultStudyRequestListenerImp&lt;GetOperationResult&gt;(TAG) {
    @Override
    public void onSuccess(GetOperationResult result) {
        super.onSuccess(result);
        updateRecomChannelPackage(mRecomChannelPackage, result);
        notifyLoadOperationDataFinish(true, mRecomChannelPackage);
    }

    @Override
    public void onError(String errorInfo) {
        super.onError(errorInfo);
        notifyLoadOperationDataFinish(false, mRecomChannelPackage);
    }
});

---------------------------------华丽的分割线--------------------
//RecomRequestManager.java
public static int doGetOperationalData(DefaultStudyRequestListenerImp&lt;GetOperationResult&gt; listener) {
    GetOperationDataRequest request = new GetOperationDataRequest(listener.successListener(), listener.errorListener());
    return RequestManager.getInstance().postRequest(request);
}
</code></pre><p>是不是看上去更加清爽？且中间层未依赖任何第三方库！</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/edu/no_dependency.jpeg" alt="no dependency"></p>
<p>StudyRequestBase 没有做任何修改，后面如果有重构的需求，在StudyRequestListenerImp 内部调整即可。</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>1、使用 StudyBaseError 统一所有异常（目前数据为空的情况还未包含进去）</p>
<p>2、建议在迭代过程中逐步替换掉CallBack，直至完全移除 StudyErrorListenerImp</p>
<p>3、RequestManager的统一（多个实例维护了两套逻辑，且造成性能浪费）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/07/图框识别预研/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/07/图框识别预研/" itemprop="url">
                  图框识别预研
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-07T16:30:56+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>设计一个算法，准确识别出dwf文件的签章区域。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>每个设计单位都有自己的模板，样式上存在差异。因此，从测试库中选出最具代表性的27张图纸。通过分析，存在以下特点：说明缺失或者超出单元格，横纵排列不一致，多格合并，有签名无角色定义，同一格对应多个签名等等。设计单位的介绍信息也会对签章区域的识别造成干扰，所以很难使用某种结构去统一定义，处理难度较大。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>联想到实际的签字场景，签字人往往先找到自己的名字，然后定位需要签字的区域，最后完成签字。那么程序中是否也能这样呢？答案是肯定的，我们很容易从审批流程中拿到相关人员信息，然后通过签字人信息分析出待签字区域，把重点放在签字上，无需关心签字人的角色或者表格样式，这样能有效排除无关信息的干扰，降低算法的复杂度。</p>
<p>按照这个思路把签字区域归纳为三种场景：</p>
<ul>
<li>签字区域与实名同单元格</li>
<li>签字区域在实名的右边单元格</li>
<li>一个单元格对应多个实名（属于第二种特殊情况）。</li>
</ul>
<p>对于盖章区域也可以采取类似的思路，根据图章的类别去找盖章区域，具体有如下几种情况：</p>
<ul>
<li>图框说明与盖章区域同单元格</li>
<li>盖章区域在图框说明的下面单元格</li>
<li>多图章合并到一个单元格</li>
<li>盖章区域无图框说明。</li>
</ul>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><img src="http://on-img.com/chart_image/5a813df0e4b024b99bfac4a6.png" alt="图框识别流程图"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/01/代码重构规范/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/01/代码重构规范/" itemprop="url">
                  代码重构规范
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-01T16:37:56+08:00">
                2018-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前阶段赶项目进度，产生了大量不符合规范的代码。</p>
<ul>
<li><p><strong>目标：</strong><br>代码结构更清晰，业务逻辑相对独立（P &amp; UC）。不包含任何平台框架的依赖（UI、Storage、IO），不用在设备或模拟器上运行，便于测试和维护。</p>
</li>
<li><p><strong>原则（Clean Architecture）：</strong></p>
<ul>
<li>框架独立</li>
<li>可测试</li>
<li>UI独立</li>
<li>数据库独立</li>
<li>所有的外部代理独立</li>
</ul>
</li>
<li><p><strong>代码架构：</strong><br><img src="http://on-img.com/chart_image/5a7132afe4b0812a0efdcf09.png" alt="代码架构"></p>
</li>
</ul>
<h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>1、P中不应该直接调用Framework或第三方类库方法</p>
<p>2、不合理的跨层引用（数据层保持相对独立）</p>
<p>3、包结构未严格按层划分</p>
<p>4、不合理命名（包、类）</p>
<p>5、部分View未定义抽象接口</p>
<p>6、Constants过于臃肿，常量最好在VO中定义</p>
<h2 id="调整-Java-amp-Kotlin"><a href="#调整-Java-amp-Kotlin" class="headerlink" title="调整(Java &amp; Kotlin)"></a>调整(Java &amp; Kotlin)</h2><p><strong>1、common包过于臃肿，进行拆分，只放整个应用都使用的公用类。</strong></p>
<table>
<thead>
<tr>
<th>/common/utils</th>
<th>-&gt;</th>
<th>/ui/utils</th>
</tr>
</thead>
<tbody>
<tr>
<td>ActivityUtils</td>
<td></td>
</tr>
<tr>
<td>AngleUtil</td>
<td></td>
</tr>
<tr>
<td>AppUpdateUtils</td>
<td></td>
</tr>
<tr>
<td>BitmapUtils</td>
<td></td>
</tr>
<tr>
<td>CameraUtil</td>
<td></td>
</tr>
<tr>
<td>ContactUtils</td>
<td></td>
</tr>
<tr>
<td>DialogUtils</td>
<td></td>
</tr>
<tr>
<td>IMMLeaksUtils</td>
<td></td>
</tr>
<tr>
<td>ManufacturerUtils</td>
<td></td>
</tr>
<tr>
<td>OpenCVUtils</td>
<td></td>
</tr>
<tr>
<td>PermissionUtil</td>
<td></td>
</tr>
<tr>
<td>QiyuUtils</td>
<td></td>
</tr>
<tr>
<td>ScreenUtils</td>
<td></td>
</tr>
<tr>
<td>ToastUtils</td>
<td></td>
</tr>
<tr>
<td>UrsUtils</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>/common/utils</th>
<th>-&gt;</th>
<th>/domain/utils</th>
</tr>
</thead>
<tbody>
<tr>
<td>NoticesUtils</td>
<td></td>
</tr>
<tr>
<td>QrUtils</td>
<td></td>
</tr>
<tr>
<td>ResPermissionUtil</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>/common/utils</th>
<th>-&gt;</th>
<th>/data/utils</th>
</tr>
</thead>
<tbody>
<tr>
<td>LabelUtils</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>/common/utils</th>
<th>-&gt;</th>
<th>/ui/navigation</th>
</tr>
</thead>
<tbody>
<tr>
<td>RouterUtil</td>
<td></td>
</tr>
<tr>
<td>ViewerNavigator</td>
<td></td>
</tr>
</tbody>
</table>
<p>//接口异常定义，属于数据层</p>
<table>
<thead>
<tr>
<th>/common/exception</th>
<th>-&gt;</th>
<th>/data/exception  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>2、data包只保留该所依赖的类，方便后期剥离。</strong></p>
<p>//不应该有跟数据层无关的POJO</p>
<table>
<thead>
<tr>
<th>/data/entity</th>
<th>-&gt;</th>
<th>/domain/bo  </th>
</tr>
</thead>
<tbody>
<tr>
<td>ImagePreviewBO</td>
<td></td>
</tr>
<tr>
<td>BimDataBO</td>
<td></td>
</tr>
</tbody>
</table>
<p>//属于业务范畴</p>
<table>
<thead>
<tr>
<th>/data/mapper</th>
<th>-&gt;</th>
<th>/domain/mapper  </th>
</tr>
</thead>
<tbody>
<tr>
<td>MapperOnData</td>
<td></td>
</tr>
<tr>
<td>MapperOnImagePreview</td>
<td></td>
</tr>
<tr>
<td>MapperOnYunXin</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>3、ui包内调整</strong></p>
<table>
<thead>
<tr>
<th>/ui/interfaces</th>
<th>-&gt;</th>
<th>/ui/view/contract </th>
</tr>
</thead>
<tbody>
<tr>
<td> 所有View接口</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>/ui/view/interfaces</th>
<th>-&gt;</th>
<th>/ui/view/adapter/model</th>
</tr>
</thead>
<tbody>
<tr>
<td>TypeFactory</td>
<td></td>
</tr>
<tr>
<td>ViewHolderFactory</td>
<td></td>
</tr>
<tr>
<td>ViewTypeModel</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="待完成（W，N，P，G）"><a href="#待完成（W，N，P，G）" class="headerlink" title="待完成（W，N，P，G）"></a>待完成（W，N，P，G）</h2><p><strong>1、Activity和Fragment未定义抽象接口（先改有P的页面）</strong></p>
<ul>
<li><p>没有P：</p>
<pre><code>P
AboutActivity   
ImagePreviewActivity
NoticesActivity
QrScanErroActivity

G
CreatePrjSucessActivity 
ProjectMarkFragment
ApprovalFileListActivity

W
CropActivity 
PhotoPreviewActivity
WebViewActivity
NoviceBootFragment
SplashFragment

N
UnityGuideFragment 
UnityLabelFragment
UnityPropListFragment
</code></pre></li>
<li><p>有P：</p>
<pre><code>P
ApproveFileInfoActivity    
ModifyProjectRoleActivity
ProjectMenuActivity
ProjectApproveFragment

W
ConfirmUploadActivity  
LoginActivity
FirstActivity
</code></pre></li>
</ul>
<p><strong>2、P不应该直接引用Context</strong></p>
<blockquote>
<p>最好隔离一切平台依赖，Framework或者第三方类库，如URS，TextUtils等</p>
</blockquote>
<pre><code>第三方库
LoginBySmsPresenter
LoginPresenter

W
AppUpdatePresenter
ShowProjectVHPresenter

P
HomePresenter
JumpToPagePresenter
TakePhotoPresenter    
QsPresenter

N
UploadListPresenter
</code></pre><p>实现一个helper工具类来隔离第三方依赖库，约定只能在P中调用</p>
<p><strong>3、Kotlin中直接将回调方法传进来，业务逻辑交给View去做是否合适？</strong></p>
<pre><code>W
ApprovalDetailPresenter
FirstEntryPresenter
PrjActionDialogPresenter
</code></pre><p>由于这类P并未持有View的引用，具体的业务逻辑还是在View中实现，将其更名为interactor比较合适。</p>
<p><strong>4、P的接口定义？</strong></p>
<p>现阶段暂不考虑</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/Kotlin重构实践/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/25/Kotlin重构实践/" itemprop="url">
                  Kotlin重构实践
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-25T18:40:56+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今年的 Google I/O 大会上，Google 宣布为 Kotlin 提供最佳支持，未来将成为 Android 的第一语言。最近在项目中已经开始用到，也踩过不少坑，这里做一个阶段性的总结。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>Kotlin 作为一种新的 JVM 语言，在设计时就考虑了 Java 互操作性，可以和 Java 代码混着一起写，也可以单独放在 src/main/kotlin 下。为了不破坏现有工程代码，将 Kotlin 代码单独存放，便于重构和开发。</p>
<p>举个例子，要使用某个控件，传统的写法是先 findViewById ，然后强转类型拿到引用，如果布局比较复杂，将会看到一大坨恶心代码。Kotlin 可以通过id直接使用控件，所以重构过程中将ButterKnife给淘汰了。。</p>
<h2 id="Android-Extensions"><a href="#Android-Extensions" class="headerlink" title="Android Extensions"></a>Android Extensions</h2><p>Kotlin 帮我们做了一些事情，只需一行代码</p>
<pre><code>import kotlinx.android.synthetic.main.＜布局＞.*
</code></pre><p>便能扩展对应的控件属性。<br>插件实现代码在 plugins/android-extensions 目录下，</p>
<p><strong>AndroidPackageFragmentProviderExtension.kt</strong></p>
<pre><code>    // Packages with synthetic properties
for (variantData in moduleData.variants) {
    for ((layoutName, layouts) in variantData.layouts) {
        fun createPackageFragment(fqName: String, forView: Boolean, isDeprecated: Boolean = false) {
            val resources = layoutXmlFileManager.extractResources(AndroidLayoutGroupData(layoutName, layouts), module)
            val packageData = AndroidSyntheticPackageData(moduleData, forView, isDeprecated, resources)
            val packageDescriptor = AndroidSyntheticPackageFragmentDescriptor(
                    module, FqName(fqName), packageData, lazyContext, storageManager, isExperimental,
                    lookupTracker, layoutName
            )
            packagesToLookupInCompletion += packageDescriptor
            allPackageDescriptors += packageDescriptor
        }

        val packageFqName = AndroidConst.SYNTHETIC_PACKAGE + &apos;.&apos; + variantData.variant.name + &apos;.&apos; + layoutName

        createPackageFragment(packageFqName, false)
        createPackageFragment(packageFqName + &quot;.view&quot;, true)
    }
}
</code></pre><p>packageFqName 表示import的虚拟包名，建立布局文件的引用。解析布局文件的逻辑在 <strong>AndroidLayoutXmlFileManager.kt</strong> 中，看它的 extractResources 方法！</p>
<pre><code>fun extractResources(layoutGroupFiles: AndroidLayoutGroupData, module: ModuleDescriptor): List&lt;AndroidResource&gt; {
    return filterDuplicates(doExtractResources(layoutGroupFiles, module))
}
...
protected abstract fun doExtractResources(layoutGroup: AndroidLayoutGroupData, module: ModuleDescriptor): AndroidLayoutGroup
</code></pre><p>主要逻辑在 doExtractResources 方法中，它其实是一个抽象方法，具体实现在 <strong>IDEAndroidLayoutXmlFileManager.kt</strong></p>
<pre><code>override fun doExtractResources(layoutGroup: AndroidLayoutGroupData, module: ModuleDescriptor): AndroidLayoutGroup {
    val layouts = layoutGroup.layouts.map { layout -&gt;
        val resources = arrayListOf&lt;AndroidResource&gt;()
        layout.accept(AndroidXmlVisitor { id, widgetType, attribute -&gt;
            resources += parseAndroidResource(id, widgetType, attribute.valueElement)
        })
        AndroidLayout(resources)
    }

    return AndroidLayoutGroup(layoutGroup.name, layouts)
}
</code></pre><p>读取 xml 标签的逻辑在 <strong>AndroidXmlVisitor.kt</strong> 中，上面传入了一个回调方法作为参数，用来记录遍历标签的 Id 和 Tpye 信息。</p>
<pre><code>class AndroidXmlVisitor(val elementCallback: (ResourceIdentifier, String, XmlAttribute) -&gt; Unit) : XmlElementVisitor() {

    ...

    override fun visitXmlTag(tag: XmlTag?) {
        val localName = tag?.localName ?: &quot;&quot;
        if (isWidgetTypeIgnored(localName)) {
            tag?.acceptChildren(this)
            return
        }

        val idAttribute = tag?.getAttribute(AndroidConst.ID_ATTRIBUTE_NO_NAMESPACE, AndroidConst.ANDROID_NAMESPACE)
        if (idAttribute != null) {
            val idAttributeValue = idAttribute.value
            if (idAttributeValue != null) {
                val xmlType = tag.getAttribute(AndroidConst.CLASS_ATTRIBUTE_NO_NAMESPACE)?.value ?: localName
                val name = androidIdToName(idAttributeValue)
                if (name != null) elementCallback(name, xmlType, idAttribute)
            }
        }

        tag?.acceptChildren(this)
    }
}
</code></pre><p>androidIdToName 方法用正则表达式提取出id的名称。代码在 <strong>AndroidConst.kt</strong> 中</p>
<pre><code>object AndroidConst {
    fun androidIdToName(id: String): ResourceIdentifier? {
        val values = AndroidConst.IDENTIFIER_REGEX.matchEntire(id)?.groupValues ?: return null
        val packageName = values[3]
        return ResourceIdentifier(values[4], if (packageName.isEmpty()) null else packageName)
    }
}
</code></pre><p>到这里大概就能明白，Activity 中为啥能够直接使用布局中的View了。。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Kotlin 能够扩展一个类的新功能而无需继承该类，前面介绍了类属性的扩展，那么如何扩展一个类的方法呢？声明一个扩展函数，使用被扩展的类作为前缀，就拿 Context 类来说：</p>
<pre><code>//ContextExtensions.kt
inline fun &lt;reified T : Activity&gt; Context.startActivity(
        params: Map&lt;String, String?&gt;?) {
    val intent = Intent(this, T::class.java)
    var setEntry = params?.entries
    setEntry?.forEach { intent.putExtra(it.key, it.value) }
    startActivity(intent)
}
</code></pre><p>函数在 Kotlin 中作为第一等公民，可以在文件的最顶层声明，无需要像 Java 一样创建一个类来保存。这里 this 关键字对应函数的调用者对象。<br>最后，在 Activity 定义的 startActivity 方法中调用：</p>
<pre><code>class InviteMemberActivity : BaseActivity(), IView {
     ...
    companion object {
        fun startActivity(context: Context?, prjId: String?, prjName: String?, shortUrl: String?) {
            context?.let {
                val params = mapOf(PROJECT_ID to prjId, PROJECT_NAME to prjName, SHORT_URL to shortUrl)
                it.startActivity&lt;InviteMemberActivity&gt;(params)
            }
        }
    }
}
</code></pre><p>说明一下， Kotlin 中没有 static 方法，因此相应的方法应该放在 companion object 中，如果从 Java 中调用这些方法，需要添加 @JvmStatic 注解。另外，let 函数默认将当前对象作为闭包的 it 参数，返回值是函数里面最后一行，或者指定 return。如果上面 context 为 null，let 方法将不会执行！</p>
<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>Kotlin 提供了一种数据类，只需要在 class 前面加上 data 关键字修饰，默认为所有属性实现了 getter、setter、equal、hashcode、toString 等方法，所以直接将项目中的 Lombok 框架给移除了。</p>
<p>Java 中一个普通的 POJO 可以如下定义：</p>
<pre><code>//POJO
data class ProjectDetailDTO(
    var prjStatus: Int = 0,
    var prjId: String? = null,
    var prjTitle: String? = null,
    var prjLabel: String? = null,
    var prjDesc: String? = null, 
    var prjNotice: String? = null,
     ...
)

//java
public class MapperOnData {
    ...
    public static ProjectDetailDTO fromPO(ProjectDetailPO src) {
        if (src == null) {
            return null;
        }
        ProjectDetailDTO dest = new ProjectDetailDTO();
        ...
        return dest;
    } 
    ...
}    
</code></pre><p>这里要注意，数据类不能被 abstract, open, sealed、inner 关键字修饰。为了兼容 MapperOnData 工具类，需要包含一个无参构造函数，所以给所有属性都指定了默认值。</p>
<p>Kotlin 的语法不仅简洁、高效，同时还支持 Lamada 表达式、操作符、空安全、类型检查与转换等等，实际开发中代码精简行数接近一半。这里我不再一一举例，可以参考 <a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">语法</a> 、<a href="https://android.github.io/kotlin-guides/style.html" target="_blank" rel="external">Style guide</a></p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>重构是为了优化代码结构，使用上新语言的特性，让代码更容易理解。重构过程中，为了确保业务逻辑不丢失，通过单元测试覆盖所有场景，每次编译都会跑一遍测试用例，只有所有用例通过才能构建成功。</p>
<p>由于项目的原子性业务逻辑主要集中在 Presenter 和 UseCase 类中，因此也非常方便写测试用例。项目中使用了 Junit + Mockito + Powermock + Robolectric 框架，测试代码编译成 class 文件直接运行在 JVM 上。</p>
<p>引入 Powermock 是因为它支持 static、final、private 方法的 mock， Powermock 会创建一个新的 MockClassLoader 来加载测试用例，然后修改字节码来实现对 static 、 final 等方法的 mock。</p>
<blockquote>
<p>Kotlin 中类、方法都默认为 final 的，除非使用 open 来修饰，否则 mock 桩类会报错。</p>
</blockquote>
<p><strong>如何进行测试？</strong></p>
<p>1、添加依赖：</p>
<pre><code>testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;
</code></pre><blockquote>
<p>提供了4个注解：@Test、 @Ignore、 @BeforeTest 和 @AfterTest，这些注解会映射到相应 JUnit 4 注解</p>
</blockquote>
<p>然后在 src/test/resourcesorg/powermock/extensions/configuration.properties 中添加：</p>
<pre><code>mockito.mock-maker-class=mock-maker-inline
</code></pre><blockquote>
<p>注：Powermock 在1.7.0后实现了自己的 PowerMockMaker，目前只是简单代理了 Mockito 的 MockMaker 和修复一些已知 bug。</p>
</blockquote>
<p>2、编写测试用例。包括三个部分：</p>
<ul>
<li>数据准备。mock桩类、预设条件返回值。</li>
<li>待测试方法、成员变量调用。</li>
<li>验证。方法是否被调用、逻辑分支是否覆盖完全、返回值或属性状态是否符合预期。</li>
</ul>
<p>3、执行用例。</p>
<pre><code>./gradlew testDevReleasegUnitTest
</code></pre><p>我们的 UseCase 类中包含由 Retrofit 框架提供的 Observable，同时封装了 RxJava 的线程管理逻辑。这里使用 RxJava 提供的 TestSubscriber 类来测试，看代码：</p>
<pre><code>import org.mockito.Mockito.`when` as _when

@Before
fun setup() {
    mSubscriber = TestSubscriber()
}

@Test
@Throws(Exception::class)
fun testSetTabRemind_Person_Successs() {
       //1、准备
    _when(mRepository.updateMyTabRemindUsingPOST(ArgumentMatchers.anyString())).thenReturn(Observable.just(true))

    //2、调用
    mUseCase.setParam(ArgumentMatchers.anyString(), TabPerson)
    mUseCase.execute(mSubscriber)
    mSubscriber.awaitTerminalEvent()

    //3、验证
    verify&lt;IRepository&gt;(mRepository, never()).updateToDoTabRemindUsingPOST(ArgumentMatchers.anyString())
    verify&lt;IRepository&gt;(mRepository, times(1)).updateMyTabRemindUsingPOST(ArgumentMatchers.anyString())
    mSubscriber.assertNoErrors()
    mSubscriber.assertValue(true)
    mSubscriber.assertCompleted()
}
</code></pre><blockquote>
<p>由于 when 是 Kotlin 的保留关键字，所以对方法名做了转换 <code>when</code> as _when</p>
</blockquote>
<p>下面测试 MyProjectPresenter 的一个方法：</p>
<pre><code>@Before
override fun setUp() {
    super.setUp()
    view = PowerMockito.mock(IMyProjectView::class.java)
    mHomeUseCase = PowerMockito.spy(HomeUseCase())
    mPresenter = PowerMockito.spy(MyProjectPresenter())

    mPresenter.mMyProjectFragment = view
    mPresenter.mHomeUseCase = mHomeUseCase
}

@Test
@PrepareForTest(AppInfo::class)
fun testGetMyProjects_WhenLoadData_ThenSuccess() {
       //1、准备
    PowerMockito.mockStatic(AppInfo::class.java)
    var appInfo = PowerMockito.mock(AppInfo::class.java)
    PowerMockito.`when`(appInfo.userId).thenReturn(&quot;123&quot;)
    PowerMockito.`when`(AppInfo.getInstance()).thenReturn(appInfo)

    var projectDetail = ProjectDetailDTO()
    var list = ArrayList&lt;ProjectDetailDTO&gt;()
    list.add(projectDetail)
    mockUcBusiness(mHomeUseCase, Observable.just(list))

    //2、调用
    mPresenter.getMyProjects()

    //3、验证
    verifyBusiness(mHomeUseCase)
    verify(view).hideInitial()
    verify(view).refreshComplete()
    verify(view).render(any())
}
</code></pre><p>另外，测试用例不可避免会调用Android系统的API，在编译阶段我们依赖的是 android.jar，它没有任何实现，所有方法都是 throw new RuntimeException(“Stub!”)，只有运行在真实的Android系统上才会去加载 Framework 层的实现代码。那么运行在 JVM 上的测试代码便会出错，如果采用Mock桩类的方式，用例会比较繁琐。所以又引入 Robolectric 来解决这个问题，它实现了一套能运行在 JVM 上的 Android Shadow 代码，模拟系统 API 的调用过程。</p>
<h1 id="Dagger、Retrofit-amp-RxJava"><a href="#Dagger、Retrofit-amp-RxJava" class="headerlink" title="Dagger、Retrofit &amp; RxJava"></a>Dagger、Retrofit &amp; RxJava</h1><p>Kotlin 依然支持 Retrofit、RxJava、Dagger2 等开源框架。通过 kapt 编译器插件支持注解处理器，kapt 同样能够处理 Java 文件，是时候替换掉默认的 annotationProcessor 了。下面介绍如何使用 Dagger2：</p>
<p>在 build.gradle 中添加：</p>
<pre><code>apply plugin: &apos;kotlin-kapt&apos;
dependencies {
    kapt &quot;com.google.dagger:dagger-compiler:${DAGGER_VERSION}&quot;
 }
</code></pre><p>先实现主模块！</p>
<p><strong>ApplicationComponent</strong></p>
<pre><code>//java
@Singleton
@Component(modules = { ApplicationModule.class })
public interface ApplicationComponent {
    void inject(BimApplication application);
    ...
}
</code></pre><p><strong>ApplicationModule</strong></p>
<pre><code>@Module
class ApplicationModule(val application: BimApplication) {
    @Provides
    fun provideBimApplication() = application

     @Provides
    fun provideBimRetrofit(okHttpClient: OkHttpClient): Retrofit{
        ...
    }
     ...
}
</code></pre><p>在 BimApplication 的 OnCreat 方法中注入：</p>
<pre><code>//java
DaggerApplicationComponent.builder()
            .applicationModule(new ApplicationModule(this))
            .build().inject(this)
</code></pre><p>其中，ApplicationModule 提供全局使用的实例对象。</p>
<p>接下来，在 Activity 的生命周期内实现分模块：</p>
<p>定义 Base Module 类 <strong>AbsActivityModule</strong></p>
<pre><code>@Module
abstract class AbsActivityModule&lt;T : Activity&gt;(@JvmField var mActivity: T) {

    @Provides
    fun provideHostActivity(): T {
        return mActivity
    }
}
</code></pre><p><strong>ProjectNoticeComponent</strong></p>
<pre><code>@PerActivity
@Component(dependencies = [ApplicationComponent::class], modules = [ProjectNoticeComponent.ProjectNoticeModule::class])
interface ProjectNoticeComponent : MembersInjector&lt;ProjectNoticeActivity&gt; {

    @Module
    class ProjectNoticeModule(activity: ProjectNoticeActivity) : AbsActivityModule&lt;ProjectNoticeActivity&gt;(activity)
}
</code></pre><blockquote>
<p>与Java不同，Kotlin 中默认为静态内部类，成员内部类则用 inner 关键字修饰。</p>
</blockquote>
<p>为了方便，将 Activity 的 Component 和 Module 放在了一起。最后，Activity中注入：</p>
<pre><code>class ProjectNoticeActivity : BaseActivity(), IProjectNoticeView {
    override fun onCreate(savedInstanceState: Bundle?) {
           super.onCreate(savedInstanceState)
        DaggerProjectNoticeComponent.builder()
                .applicationComponent(applicationComponent)
                .projectNoticeModule(ProjectNoticeComponent.ProjectNoticeModule(this))
                .build()
                .injectMembers(this)
    }
</code></pre><p>Kotlin 中使用 Dagger2 是不是非常简单？Module 负责生产对象，需要使用的地方直接 @Inject 即可，项目中所有的 Presenter 和 UseCase 都是可以直接使用的，让代码进一步解耦。</p>
<p>第一节中我们使用 data 关键字定义了数据类，它可以用来承载 Json 转换过来的 Response 数据。下面将实现一个标准的网络请求。</p>
<p>创建一个API Interface文件 <strong>BimApi.kt</strong>:</p>
<pre><code>interface BimApi {
    ...
    @FormUrlEncoded
    @POST(&quot;api/m/project/modify&quot;)
    fun modifyProject(@Field(&quot;prjId&quot;) prjId: String?, @Field(&quot;prjTitle&quot;) prjTitle: String?,
                      @Field(&quot;prjNotice&quot;) prjNotice: String?): Observable&lt;ProjectDetailDTO&gt;
}
</code></pre><p>使用 Dagger 注入全局的 Retrofit 对象：</p>
<pre><code>@Singleton
class KCloudDataStore
@Inject
constructor(retrofit: Retrofit){
    ...
    fun modifyProject(prjId: String?, prjTitle: String?, prjNotice: String?): Observable&lt;ProjectDetailDTO&gt; {
        return retrofit.create(BimApi::class.java).modifyProject(prjId, prjTitle, prjNotice)
    }
}
</code></pre><p>实现了一个访问网络的方法供上层调用，并且采用 RxJava 来管理异步线程。如图：</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/KotlinRefactor/Bim%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="结构图"></p>
<p>从网络层拿到 Observable 对象，然后在 UseCase 中 subscribe </p>
<pre><code>Observable&lt;ProjectDetailDTO&gt; 
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe (object : DefaultSubscriber&lt;ProjectDetailDTO&gt;() {
        override fun onNext(projectDetailDTO: ProjectDetailDTO?) {
            super.onNext(projectDetailDTO)
            //UI Thread
            //TODO
        }
    })
</code></pre><blockquote>
<p>object 关键字声明匿名内部类</p>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>目前，新的功能已完全使用 Kotlin 进行开发，底层封装的一些通用模块暂时兼容 Java，后续会不断进行重构，直至完全切换到 Kotlin。同时，新的语言还需要一个熟悉的过程，使用上难免会产生疏忽和偏差，比如，lateinit var修饰的属性，使用前如果未初始化，运行时会报  kotlin.UninitializedPropertyAccessException。</p>
<p>尚未使用的特性，如反射、协程等。除此之外，Kotlin 几乎可以用于任何类型的开发，无论是服务器端、Web、Android 还是 Native。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://kotlinlang.org/docs/reference" target="_blank" rel="external">https://kotlinlang.org/docs/reference</a></p>
<p><a href="https://android.github.io/kotlin-guides/style.html" target="_blank" rel="external">https://android.github.io/kotlin-guides/style.html</a></p>
<p><a href="https://github.com/JetBrains/kotlin" target="_blank" rel="external">https://github.com/JetBrains/kotlin</a></p>
<p><a href="https://github.com/powermock/powermock/wiki/Mockito" target="_blank" rel="external">https://github.com/powermock/powermock/wiki/Mockito</a></p>
<p><a href="https://blog.jetbrains.com/kotlin" target="_blank" rel="external">https://blog.jetbrains.com/kotlin</a></p>
<p><a href="https://android.jlelse.eu/keddit-part-9-unit-test-with-kotlin-mockito-spek-76709812e3b6" target="_blank" rel="external">https://android.jlelse.eu/keddit-part-9-unit-test-with-kotlin-mockito-spek-76709812e3b6</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/14/Jenkins之静态代码检查/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/14/Jenkins之静态代码检查/" itemprop="url">
                  Jenkins之静态代码检查
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-14T20:04:56+08:00">
                2017-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>编码过程中不可避免会产生一些错误，如何借助工具来发现这些问题，帮助我们有效的改进代码质量。最近在项目中接入了Checksytle、Findbugs、PMD 和 Android Lint等自动化工具，AndroidStudio中都有对应的插件。本文只介绍Gradle方式，Gradle Task配合Jenkins来实时执行任务检查，方便后续的日志追踪。</p>
<p>首先，在build.gradle文件中添加：</p>
<pre><code>apply plugin: &apos;findbugs&apos;
apply plugin: &apos;checkstyle&apos;
apply plugin: &apos;pmd&apos;
</code></pre><p>接下来配置这些工具。</p>
<h1 id="Checkstyle"><a href="#Checkstyle" class="headerlink" title="Checkstyle"></a>Checkstyle</h1><p>主要是代码格式、规范的检查，可自定义扫描规则。我之前的一篇<a href="http://note.youdao.com/noteshare?id=3743e5e9baff7566955dc2af45b47b7e" target="_blank" rel="external">文章</a></p>
<pre><code>task checkstyle(type: Checkstyle) {
    ignoreFailures true    
    showViolations = true
    configFile file(&quot;${project.rootDir}/settings/checkstyle.xml&quot;)

    source &apos;src/main/java&apos;
    include &apos;**/*.java&apos;
    exclude &apos;**/gen/**&apos;
    exclude &apos;**/R.java&apos;
    exclude &apos;**/BuildConfig.java&apos;

    // empty classpath
    classpath = files()
    reports {
        xml.enabled = false
        html.enabled = true
        xml {
            destination &quot;$project.buildDir/reports/checkstyle/checkstyle.xml&quot;
        }
        html {
            destination &quot;$project.buildDir/reports/checkstyle/checkstyle.html&quot;
        }
    }
}
</code></pre><blockquote>
<p>若要编写checkstyle.xml文件，请参考<a href="http://checkstyle.sourceforge.net/config.html" target="_blank" rel="external">传送门</a></p>
</blockquote>
<h1 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h1><p>FindBugs uses static analysis to inspect Java bytecode for occurrences of bug patterns.</p>
<p>静态分析方式扫描 Java 字节码，发现其中的可能出现 bug 的代码，它能发现一些常规的逻辑错误。</p>
<p><strong>注：必须先编译生成class文件，否则会报错</strong></p>
<pre><code>task findbugs(type: FindBugs,dependsOn: &quot;assembleQaRelease&quot;) {
    ignoreFailures = true
    effort = &quot;default&quot;
    reportLevel = &quot;medium&quot;
    excludeFilter = new File(&quot;${project.rootDir}/settings/findbugs-android-exclude.xml&quot;)
    classes = files(&quot;${project.rootDir}/app/build/intermediates/classes&quot;)
    source = fileTree(&apos;src/main/java/&apos;)
    classpath = files()
    reports {
        xml.enabled = false
        html.enabled = true
        xml {
            destination &quot;$project.buildDir/reports/findbugs/findbugs-output.xml&quot;
        }
        html {
            destination &quot;$project.buildDir/reports/findbugs/findbugs-output.html&quot;
        }
    }
}
</code></pre><blockquote>
<p>定义过滤文件，请参考 <a href="http://findbugs.sourceforge.net/manual/filter.html" target="_blank" rel="external">传送门</a></p>
</blockquote>
<h1 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a>PMD</h1><p>名字还没有统一的说法，下面是官网找到的几种解释：</p>
<ul>
<li>Pretty Much Done</li>
<li>Project Mess Detector</li>
<li>Project Monitoring Directives</li>
<li>Project Meets Deadline</li>
<li>Programming Mistake Detector</li>
<li>Pounds Mistakes Dead</li>
<li>PMD Meaning Discovery (recursion, hooray!)</li>
<li>Programs of Mass Destruction</li>
<li>Programming Meticulous coDe</li>
</ul>
<p>它是基于源码的检查，能扫描出废弃变量和对象、空catch语句等。不仅支持Java，还支持JS、XML等其他语言，与FindBugs形成互补。</p>
<pre><code>task pmd(type: Pmd) {
    ruleSetFiles = files(&quot;${project.rootDir}/settings/pmd-ruleset.xml&quot;)
    ignoreFailures = true
    ruleSets = []

    source &apos;src&apos;
    include &apos;**/*.java&apos;
    exclude &apos;**/gen/**&apos;

    reports {
        xml.enabled = false
        html.enabled = true
        xml {
            destination &quot;$project.buildDir/reports/pmd/pmd.xml&quot;
        }
        html {
            destination &quot;$project.buildDir/reports/pmd/pmd.html&quot;
        }
    }
}
</code></pre><blockquote>
<p>自定义pmd-ruleset.xml文件，可参考 <a href="http://pmd.sourceforge.net/pmd-4.3.0/howtomakearuleset.html" target="_blank" rel="external">传送门</a></p>
</blockquote>
<h1 id="Android-Lint"><a href="#Android-Lint" class="headerlink" title="Android Lint"></a>Android Lint</h1><p>专门为Android工程打造的静态代码分析工具，除了检查潜在的问题外，还能对Android的资源文件、废弃无用资源进行扫描。</p>
<pre><code>android {
    lintOptions {
        checkReleaseBuilds true
        abortOnError true
        lintConfig file(&quot;lint.xml&quot;)
        htmlReport true
        htmlOutput file(&quot;$project.buildDir/reports/lint/lint.html&quot;)
    }
}
</code></pre><blockquote>
<p>lint.xml文件定义 Lint 检查项，置于 Android 项目的根目录。<a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">传送门</a></p>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这里要说明的是，FindBugs和PMD的输出文件有xml和html两种格式，同时启用两种格式会报错，解决办法是关掉其中一种，或者通过配置让脚本执行两遍。一般情况下，配置文件采用官方默认即可，也可根据团队需求自定义规则。</p>
<p>另外，自动化工具部分规则还存在争议，它能帮我们找出代码缺陷，但扫描结果还需开发人员确认是否修改或选择忽略。为了避免执行中断，建议启用ignoreFailures属性。</p>
<p>为了管理任务，添加check task的依赖：</p>
<pre><code>check.dependsOn &apos;checkstyle&apos;, &apos;findbugs&apos;, &apos;pmd&apos;, &apos;lint&apos;
</code></pre><p>然后输入：</p>
<pre><code>gradlew check
</code></pre><p>依次执行上面的任务。</p>
<p>Jenkins每小时都会去检查代码，如果产生变更则自动触发任务，并在项目面板中显示报告文件。如图：<br><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/CodeCheck/Jenkins-codecheck.jpeg" alt="report"></p>
<blockquote>
<p>本文所参考的项目 <a href="https://github.com/bufferapp/android-guidelines" target="_blank" rel="external">传送门</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/通知优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/15/通知优化/" itemprop="url">
                  通知优化
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-15T19:39:56+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在对项目中的Notification和短链跳转进行优化，APP退出之后，从外部进入目标页面，避免直接返回到桌面。Android系统采用任务栈来管理Activity。</p>
<p><img src="/images/notification/backstack.png" alt="任务栈"></p>
<p>目前返回是统一指向主页面，实现方式无非是两种：一是先启动再跳转，二先跳转目标页然后返回主页。</p>
<p>具体方案如下：</p>
<h2 id="一、TaskStackBuilder"><a href="#一、TaskStackBuilder" class="headerlink" title="一、TaskStackBuilder"></a>一、TaskStackBuilder</h2><p>用于构造返回任务栈，仅支持22以上的版本。<br>在AndroidManifest.xml配置Activity关系</p>
<pre><code>&lt;activity android:name=&quot;.NoticesActivity&quot;
      android:parentActivityName=&quot;.HomeActivity&quot;/&gt;
</code></pre><p>系统会读取该属性，以确定当用户返回时应该启动哪一个Activity。</p>
<p>代码</p>
<pre><code>//启动通知Activity时，拉起主页面Activity
Intent noticeIntent = new Intent();
noticeIntent.setClass(this, NoticesActivity.class);

//创建返回栈
TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);
//添加Activity到返回栈
stackBuilder.addParentStack(HomeActivity.class);
//添加Intent到栈顶
stackBuilder.addNextIntent(noticeIntent);

PendingIntent pendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);
</code></pre><h2 id="二、PendingIntent-getActivities"><a href="#二、PendingIntent-getActivities" class="headerlink" title="二、PendingIntent.getActivities()"></a>二、PendingIntent.getActivities()</h2><p>先看看官方的解释：</p>
<p><img src="/images/notification/getActivities.jpeg" alt="getActivities"></p>
<p>首先需要构建一个Intent数组，其中第一个Intent对象将会被额外的启动一个栈（启动模式设置为singleTask），所以将HomeActivity设置为intents[0]对象.</p>
<p>而intents数组中最后一个，将作为PendIntent的关键，也就是点击之后需要跳转的目标页面。</p>
<p>代码：</p>
<pre><code>Intent noticeIntent = new Intent();
Intent homeIntent = new Intent();
noticeIntent.setClass(this, NoticesActivity.class);
homeIntent.setClass(this, HomeActivity.class);
//按顺序排列
Intent[] intents = new Intent[]{homeIntent, noticeIntent};
PendingIntent pendingIntent = PendingIntent.
        getActivities(this, 0, intents, PendingIntent.FLAG_UPDATE_CURRENT);
</code></pre><h2 id="三、启动多个页面"><a href="#三、启动多个页面" class="headerlink" title="三、启动多个页面"></a>三、启动多个页面</h2><p>1、过渡页中一次性启动多个页面</p>
<pre><code>Intent[] intents = {homeIntent, noticeIntent};
context.startActivities(intents);
</code></pre><p>2、在页面中依次按顺序启动页面，并管理传入的参数，实现不同目标页的跳转（稍微复杂）</p>
<h2 id="四、加一个flag，重构返回逻辑（实现简单）"><a href="#四、加一个flag，重构返回逻辑（实现简单）" class="headerlink" title="四、加一个flag，重构返回逻辑（实现简单）"></a>四、加一个flag，重构返回逻辑（实现简单）</h2><p>代码：</p>
<pre><code>Intent msgIntent =new Intent(context,ProjectDetailHomeActivity.class);
//判断是否是点击notification后到的详细界面
startIntent.putExtra(&quot;notificationFlag&quot;,true);
</code></pre><p>重写BaseActivity的返回逻辑</p>
<pre><code>notificationFlag =intent.getBooleanExtra(&quot;notificationFlag&quot;,false);
if(notificationFlag){
     Intent intent=new Intent(this,MainActivity.class);
     startActivity(intent);
     finish();
}
</code></pre><p>也可以重写Activity的onBackPressed（）方法，判断当前Activity是否处于任务栈的底部，如果是则跳转首页，否则正常返回。</p>
<blockquote>
<p>注意：为了确保Activity处于栈底，应该把启动模式设置为singleTask。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在项目中无法直接打开目标详情页，中间还需经过一个过度组件来准备数据，和相关初始化工作（权限、网络通信、状态更新、未登录等），所以方案一、二排除。由于通知类型较多，需要改造较多的目标页面，并对不同的flag进行管理，方案三实现略微复杂。最后采用了方案四！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/注解的那些事/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/24/注解的那些事/" itemprop="url">
                  注解的那些事
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-24T19:55:53+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是注解（Annotation）？"><a href="#什么是注解（Annotation）？" class="headerlink" title="什么是注解（Annotation）？"></a>什么是注解（Annotation）？</h1><p><strong>首先要回答为啥要使用注解？它能解决什么样的问题？</strong></p>
<blockquote>
<p>简单来说它能告诉编译器按我们的意图做一些事情，具有标识、减少代码量，让代码结构更加清晰的作用。</p>
</blockquote>
<p>For example，在Android开发过程中，要获取一个控件对象必须大量调用 findViewById()方法，并且还的进行类型强转，使用起来非常麻烦。</p>
<p>为了解决这个问题ButterKnife应运而生，只需添加一行注解便能实现xml控件的绑定。<br>除此之外，Retrofit、Rxjava、OKHttp等开源项目也大量使用了注解。</p>
<p><strong>总结一下,注解就是Java提供了一种源程序中的元素关联任何信息或者任何元数据（metadata）的途径和方法</strong>。</p>
<blockquote>
<p>它是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
</blockquote>
<p>常见的作用有以下几种：</p>
<ul>
<li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能。（retrofit网络配置）</li>
<li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</li>
</ul>
<h1 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h1><p>JDK1.5开始，Java提供了注解的功能，允许开发者定义和使用自己的注解类型，该功能由一个定义注解类型的语法和描述一个注解声明的语法，读取注解的API，一个使用注解修饰的class文件和一个注解处理工具组成。整个过程包括：注解定义、使用注解、初始化注解处理、处理注解。</p>
<h2 id="注解类型"><a href="#注解类型" class="headerlink" title="注解类型"></a>注解类型</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p> 元注解是指注解的注解。包括  @Retention @Target @Document @Inherited四种。</p>
<p><strong>1、@Retention: 定义注解的保留策略</strong></p>
<pre><code>@Retention(RetentionPolicy.SOURCE)//注解仅存在于源码中，在class字节码文件中不包含
@Retention(RetentionPolicy.CLASS)// 默认的保留策略，注解会在class字节码文件中存在，但运行时无法得
@Retention(RetentionPolicy.RUNTIME)// 注解会在class字节码文件中存在，在运行时可以通过反射获取到
</code></pre><p><strong>2、@Target：定义注解的作用目标</strong></p>
<p>其定义的源码为： </p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
 public @interface Target {
     ElementType[] value();
 }
@Target(ElementType.TYPE)   //接口、类、枚举、注解
@Target(ElementType.FIELD) //字段、枚举的常量
@Target(ElementType.METHOD) //方法
@Target(ElementType.PARAMETER) //方法参数
@Target(ElementType.CONSTRUCTOR)  //构造函数
@Target(ElementType.LOCAL_VARIABLE)//局部变量
@Target(ElementType.ANNOTATION_TYPE)//注解
@Target(ElementType.PACKAGE) ///包   
</code></pre><p>由以上的源码可以知道，他的elementType 可以有多个，一个注解可以为类的，方法的，字段的等等。</p>
<p><strong>3、@Document：说明该注解将被包含在javadoc中</strong></p>
<p><strong>4、@Inherited：说明子类可以继承父类中的该注解</strong></p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>Java中表示声明一个注解类的关键字。<br>使用@interface 表示我们已经继承了java.lang.annotation.Annotation类，这是一个注解的基类接口</p>
<pre><code>public @interface MyAnnotation { 

}
</code></pre><p>通常在使用时会为注解类加上两个注解：</p>
<pre><code>@Target(ElementType.TYPE,ElementType.METHOD)、
@Retention(RetentionPolicy.RUNTIME)
</code></pre><p>表示注解会在class字节码文件中存在，在运行时可以通过反射获取到。同时，该注解可以是类的注解或者方法的注解。</p>
<p>Annotation类型里面的参数设定: </p>
<ul>
<li>只能用public或默认(default)这两个访问权修饰.</li>
<li>成员变量只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String,Enum,Class,annotations等数据类型,以及这一些类型的数组。</li>
<li>成员变量以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。如果只有一个成员变量,最好把成员变量名称设为value.</li>
</ul>
<p>例如ButterKnife中 BindView注解的申明：</p>
<pre><code>@Retention(CLASS) @Target(FIELD)
public @interface BindView {
  /** View ID to which the field will be bound. */
  @IdRes int value();
}
</code></pre><h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><p>根据所标识的注解完成未完成的工作</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>利用Java的反射机制，但是运行时效率低下，因为JVM不能够在反射之前做任何假象和优化，另外在参数检查、可见性检查、调用权限、分配内存等方面仍然要占用更多的时间。如下代码实现了对象与控件的绑定：</p>
<pre><code>/**

 * @param currentClass

 *            当前类，一般为Activity或Fragment

 * @param sourceView

 *            待绑定控件的直接或间接父控件

 */

public static void initBindView(Object currentClass, View sourceView) {

    // 通过反射获取到全部属性，反射的字段可能是一个类（静态）字段或实例字段

    Field[] fields = currentClass.getClass().getDeclaredFields();

    if (fields != null &amp;&amp; fields.length &gt; 0) {

        for (Field field : fields) {

            // 返回BindView类型的注解内容

            BindView bindView = field.getAnnotation(BindView.class);

            if (bindView != null) {

                int viewId = bindView.id();

                boolean clickLis = bindView.click();

                try {

                    field.setAccessible(true);

                    if (clickLis) {

                        sourceView.findViewById(viewId).setOnClickListener(

                                (OnClickListener) currentClass);

                    }

                    // 将currentClass的field赋值为sourceView.findViewById(viewId)

                    field.set(currentClass, sourceView.findViewById(viewId));

                } catch (Exception e) {

                    e.printStackTrace();

                }

            }

        }

    }

}
</code></pre><h3 id="APT-Annotation-Processing-Tool"><a href="#APT-Annotation-Processing-Tool" class="headerlink" title="APT(Annotation Processing Tool)"></a>APT(Annotation Processing Tool)</h3><ul>
<li>注解处理器（AbstractProcess）</li>
<li>代码处理（JavaPoet库）</li>
<li>处理器注册（AutoService）</li>
<li><p>annotationProcessor(Android官方插件,在编译期间自动生成的代码,不会降低运行效率）</p>
<blockquote>
<p>Annotation处理器根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。</p>
</blockquote>
<p>常见的项目： Dagger2 、 ButterKnife<br><a href="http://blog.csdn.net/xx326664162/article/details/68490059" target="_blank" rel="external">http://blog.csdn.net/xx326664162/article/details/68490059</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>EventBus、Retrofit 属于反射，反射可以动态访问和修改对象，让代码更加灵活，处理不当会对性能造成影响。在如今硬件设备上，牺牲部分性能并不会影响用户体验。在实际项目中，可以考虑开发埋点注解框架，减少使用者的学习成本和出错率。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/26/进程保活/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/26/进程保活/" itemprop="url">
                  进程保活是耍流氓吗？
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-26T19:30:23+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>保活是不是耍流氓？</strong></p>
<p>很多场景如果要想为用户服务，就必须有一个进程常驻，以便在特定的时候做特定的事情。</p>
<p>1、实现IM，推送，定位等功能。</p>
<p>2、某些系统广播无法静态注册。</p>
<blockquote>
<p>android.intent.action.SCREEN_ON</p>
<p>android.intent.action.SCREEN_OFF</p>
<p>android.intent.action.BATTERY_CHANGED</p>
<p>android.intent.action.CONFIGURATION_CHANGED</p>
<p>android.intent.action.TIME_TICK</p>
</blockquote>
<p>存在问题：<br>增加系统性能开销，所以结合内存、电池等消耗找到一个平衡点。</p>
<p>Android系统中在没有白名单的情况下，要做到应用不被杀死基本不可能的，但是我们可以让应用尽可能的不被杀死，如果杀死也能够自动复活。</p>
<h1 id="Android进程的优先级"><a href="#Android进程的优先级" class="headerlink" title="Android进程的优先级"></a>Android进程的优先级</h1><p>1、前台进程(Foreground process)</p>
<ul>
<li>某个进程持有一个正在与用户交互的Activity并且该Activity正处于resume的状态。 </li>
<li>某个进程持有一个Service，并且该Service与用户正在交互的Activity绑定。 </li>
<li>某个进程持有一个Service，并且该Service调用startForeground()方法使之位于前台运行。 </li>
<li>某个进程持有一个Service，并且该Service正在执行它的某个生命周期回调方法，比如onCreate()、 onStart()或onDestroy()。 </li>
<li>某个进程持有一个BroadcastReceiver，并且该BroadcastReceiver正在执行其onReceive()方法。</li>
</ul>
<p>表示用户正在使用的程序，一般系统是不会杀死前台进程的，除非用户强制停止应用或者系统内存不足等极端情况会杀死。</p>
<p>2、可见进程(Visible process)</p>
<ul>
<li>拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）。 </li>
<li>拥有绑定到可见（或前台）Activity 的 Service</li>
</ul>
<p>用户仅仅可见，无法交互！<br>一般系统也是不会杀死可见进程的，除非要在资源吃紧的情况下，要保持某个或多个前台进程存活</p>
<p>3、服务进程(Service process)</p>
<ul>
<li>某个进程中运行着一个Service且该Service是通过startService()启动的，与用户看见的界面没有直接关联。</li>
</ul>
<p>在内存不足以维持所有前台进程和可见进程同时运行的情况下，服务进程会被杀死</p>
<p>4、后台进程(Background process)</p>
<ul>
<li>在用户按了”back”或者”home”后,程序本身看不到了,但是其实还在运行的程序，比如Activity调用了onStop方法</li>
</ul>
<p>系统可能随时终止它们，回收内存</p>
<p>5、空进程(Empty process)</p>
<ul>
<li>某个进程不包含任何活跃的组件时该进程就会被置为空进程，</li>
</ul>
<p>完全没用,直接干掉</p>
<h1 id="Android进程的回收策略"><a href="#Android进程的回收策略" class="headerlink" title="Android进程的回收策略"></a>Android进程的回收策略</h1><p>系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app, 这套杀进程回收内存的机制就叫<strong>Low Memory Killer</strong>，位于kernel层。</p>
<p>不同手机的内存阈值也不同，可以通过cat /sys/module/lowmemorykiller/parameters/minfree文件查看，一旦低于该值,Android便开始按顺序关闭进程。因此Android最先结束优先级最低的空进程。</p>
<p>进程的优先级是通过进程的oom_adj值来反映的。Linux内核为每个系统进程分配了一个oom_adj值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收，oom_adj值定义在com.android.server.am.ProcessList类中。</p>
<table>
<thead>
<tr>
<th>adj级别</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNKNOWN_ADJ</td>
<td>16</td>
<td>预留的最低级别，一般对于缓存的进程才有可能设置成这个级别</td>
</tr>
<tr>
<td>CACHED_APP_MAX_ADJ</td>
<td>15</td>
<td>缓存进程，空进程，在内存不足的情况下就会优先被kill</td>
</tr>
<tr>
<td><strong>CACHED_APP_MIN_ADJ</strong></td>
<td>9</td>
<td>缓存进程，也就是空进程</td>
</tr>
<tr>
<td><strong>SERVICE_B_ADJ</strong></td>
<td>8</td>
<td>不活跃的进程</td>
</tr>
<tr>
<td>PREVIOUS_APP_ADJ</td>
<td>7</td>
<td>切换进程</td>
</tr>
<tr>
<td>HOME_APP_ADJ</td>
<td>6</td>
<td>与Home交互的进程</td>
</tr>
<tr>
<td><strong>SERVICE_ADJ</strong></td>
<td>5</td>
<td>有Service的进程</td>
</tr>
<tr>
<td>HEAVY_WEIGHT_APP_ADJ</td>
<td>4</td>
<td>高权重进程</td>
</tr>
<tr>
<td>BACKUP_APP_ADJ</td>
<td>3</td>
<td>正在备份的进程</td>
</tr>
<tr>
<td><strong>PERCEPTIBLE_APP_ADJ</strong></td>
<td>2</td>
<td>可感知的进程，比如那种播放音乐</td>
</tr>
<tr>
<td><strong>VISIBLE_APP_ADJ</strong></td>
<td>1</td>
<td>可见进程</td>
</tr>
<tr>
<td><strong>FOREGROUND_APP_ADJ</strong></td>
<td>0</td>
<td>前台进程</td>
</tr>
<tr>
<td>PERSISTENT_SERVICE_ADJ</td>
<td>-11</td>
<td>重要进程</td>
</tr>
<tr>
<td>PERSISTENT_PROC_ADJ</td>
<td>-12</td>
<td>核心进程</td>
</tr>
<tr>
<td>SYSTEM_ADJ</td>
<td>-16</td>
<td>系统进程</td>
</tr>
<tr>
<td>NATIVE_ADJ</td>
<td>-17</td>
<td>系统起的Native进程</td>
</tr>
</tbody>
</table>
<p>oom_adj的值越小，进程的优先级越高，普通进程oom_adj值是大于等于0的，而系统进程oom_adj的值是小于0的，第三方应用一般只能干掉4以上的进程。我们可以通过<strong>ps|grep</strong>和<strong>cat /proc/process id/oom_adj</strong>查看当前进程的oom_adj值。</p>
<h1 id="常见的几种保活方案"><a href="#常见的几种保活方案" class="headerlink" title="常见的几种保活方案"></a>常见的几种保活方案</h1><h2 id="防止被杀死"><a href="#防止被杀死" class="headerlink" title="防止被杀死"></a>防止被杀死</h2><ul>
<li><p>降低oom_adj的值，提高进程优先级，减少内存占用。<br>如锁屏时候进程中开启一个像素的透明Activity，这样进程变为前台进程防止被杀死。</p>
</li>
<li><p>前台服务，使用Android的一个通知栏的bug，调用startForegound发送一个空的notification，在通知栏没有任何通知，而且进程同样处于低oom_adj状态。4.3以后通过开两个service绑定到同一个通知ID，然后干掉其中一个移除通知显示，保留前台服务（Android7.1修复了这个漏洞）。</p>
</li>
</ul>
<ul>
<li>业务多进程实现，保持单进程最小内存占用，增大存活几率。目前主流应用大多采用多进程的方式</li>
</ul>
<h2 id="如何拉活"><a href="#如何拉活" class="headerlink" title="如何拉活"></a>如何拉活</h2><p><strong>1、利用系统广播拉活（ 开机、网络变化、文件挂载等）</strong></p>
<blockquote>
<p>缺点：可能被安全软件禁用，不可控，不能保证立即拉活（程序被强制干掉，不会接收到广播）。同时,Android N删除了三项隐式广播，后续不排除会删除其他系统广播，所以在开发过程中应该减少对系统广播的依赖。</p>
<p>解决：第三方相互唤醒，很多大厂都采用该方案。</p>
</blockquote>
<p><strong>2、利用系统service机制拉活。</strong><br>onStartCommand方法必须具有一个整形的返回（START_STICKY），这个整形的返回值用来告诉系统在服务启动完毕后，被杀死后对应的操作。也可以在onDestroy方法中重建。</p>
<blockquote>
<p>缺点：<br>1、内存不足，回收后，尝试重新创建。<br>2、多次kill后不会拉活。<br>3、强制kill后 不会重启</p>
</blockquote>
<p><strong>3、进程守护。</strong><br>利用native进程拉活（5.0后不可靠，主进程和子进程一起杀死）</p>
<ul>
<li>fork新进程进行守护，轮训定时器判断</li>
<li>主进程中创建监控并持有文件锁，新进程中申请文件锁被阻塞 ，获得锁则拉活.</li>
</ul>
<blockquote>
<p>解决：可以想办法让子进程脱离主进程所属进程组，切断联系。<a href="http://blog.csdn.net/yyh352091626/article/details/50542554" target="_blank" rel="external">http://blog.csdn.net/yyh352091626/article/details/50542554</a></p>
</blockquote>
<p><strong>4、JobSheduler机制拉活（5.0后的替代方案）</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上几种保活方案并不是完全可靠，只能降低被杀死的概率。系统有自己特定的进程管理方式，官方不推荐使用各类保活手段，除非强烈的产品需求，各种利用系统漏洞的保活方案一定要慎用，保活会产生一些性能和电量的消耗，甚至引发不可预知的风险。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpeg"
               alt="潘威" />
          <p class="site-author-name" itemprop="name">潘威</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潘威</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>

<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/打造一个通用Adapter/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/28/打造一个通用Adapter/" itemprop="url">
                  打造一个通用Adapter
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T21:33:54+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目通知模块涉及到的通知类型多达三四十种，并且消息列表分散在多个页面。本文使用RecycleView展示多种布局类型，考虑到通知消息格式具有一定的相似性，所以把它做成一个通用Adapter，便于后期的扩展和维护。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Android系统在v7包中提供了一种新的组件RecycleView，通过LayoutManager来实现过去常常使用的ListView和GridView，使用过程中重写RecycleViewAdapter的三个方法：</p>
<blockquote>
<p>1、首先在getItemViewType方法中返回固定的类型标识viewType。ItemView的type类型，由服务端返回的数据Model决定。</p>
<p>2、然后在onCreateViewHolder中根据viewType参数，也就是getItemViewType的返回值来判断需要创建的ViewHolder类型。</p>
<p>3、最后在onBindViewHolder方法中对ViewHolder的具体类型进行判断，分别为不同类型的ViewHolder进行绑定数据与逻辑处理。</p>
</blockquote>
<p>所以Adapter的实现代码如下：</p>
<pre><code>    @Override
public int getItemViewType(int position) {
    if (mNoticesMessageDTOs != null &amp;&amp; position &lt; mNoticesMessageDTOs.size()) {
        return mNoticesMessageDTOs.get(position).getEventType();
    }
}

@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    RecyclerView.ViewHolder viewHolder = null;
    switch (viewType) {
        ......
        case Constants.EventType.FOLDER_CREATE:
        case Constants.EventType.FOLDER_RESTORE:
        case Constants.EventType.FOLDER_DELETE:
            viewHolder = new NoticeCardVHolder(parent, mViewComponent);
            break;
        case Constants.EventType.DISCUSS_NEW_TOPIC:
        case Constants.EventType.DISCUSS_NEW_COMMIT:
        case Constants.EventType.DISCUSS_REPLY_COMMIT:
        case Constants.EventType.DISCUSS_AT_YOU:
            viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
            break;

    }
    return viewHolder;
}

@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
    if (holder instanceof NoticeCardVHolder) {
        ((NoticeCardVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectVHolder) {
        ((NoticeProjectVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectAnounceVHolder) {
        ((NoticeProjectAnounceVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeLabelVHolder) {
        ((NoticeLabelVHolder) holder).render(mNoticesMessageDTOs.get(position));
    } else if (holder instanceof NoticeProjectApproveVHolder) {
        ((NoticeProjectApproveVHolder) holder).render(mNoticesMessageDTOs.get(position));
    }
}

@Override
public int getItemCount() {
    return mNoticesMessageDTOs.size();
}
</code></pre><p>很明显看出，这种实现方式存在如下缺陷：</p>
<p>1、类型检查与转换方式低效。由于在onCreateViewHolder中根据不同类型创建了不同的ViewHolder，所以onBindViewHolder方法需要针对不同类型的ViewHolder进行数据绑定与逻辑处理。</p>
<p>2、不利于扩展和维护。数据源是从服务端获取，当需求发生变化，比如新增其他通知类型，或者Model数据结构发生变化时，需要重写以上三个方法。随着类型的逐渐增多，Adapter会越来越臃肿，变得难以维护。</p>
<p>3、代码的重复实现。每种类型的ViewHolder单独实现事件点击、设置已读样式等。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>针对前文所提到的三点问题，从getItemViewType、onCreateViewHolder、onBindViewHolder这三个方法入手，提出以下解决思路：</p>
<p><strong>1、实现BaseViewHolder。</strong>从不同ViewHolder中抽象出相似的功能，比如点击跳转，设置已读样式，头像的显示规则等，避免重复实现。在继承RecyclerView.ViewHolder的基础上派生出BaseViewHolder，所有ViewHolder必须继承BaseViewHolder，并在此基础上扩展。</p>
<pre><code>abstract public class BaseVHolder extends RecyclerView.ViewHolder {

    public BaseVHolder(View itemView, ViewComponent component) {
        super(itemView);
        if (component != null) {
            component.inject(this);
        }
    }

    public void render(NoticesMessageDTO noticesMessageDTO) {

    }

    protected void modifyLayout() {
      ......
    }

    public CharSequence renderSpan(String text, String color, boolean isBold, boolean isDelete) {
       ......
    }

    public void setUserImage(SimpleDraweeView mUserAvator, NoticesMessageDTO.ContentObj contentObj) {
        ......
    }

    public void parseDeleteLine(SpannableStringBuilder operateStr) {
        ......
    }

    //页面路由统一处理跳转事件
    public void setOnNoticesItemClickListener(final NoticesMessageDTO noticesMessageDTO) {
        ......
    }

    //设置item为已读样式
    protected void setItemReaded() {
            ......
    }

}
</code></pre><p><strong>2、合并ViewHolder。</strong>将所有通知类型（服务端控制）按视觉样式分为五个大类，并创建五种不同的itemView，然后根据viewType实现五种ViewHolder。如下是卡片相关通知类型。</p>
<pre><code>public class NoticeCardVHolder extends BaseVHolder {
    @BindView(R.id.tv_user_name)
    TextView mUserName;
    @BindView(R.id.project_name)
    TextView mProjectName;
    @BindView(operate)
    TextView mOperate;
    @BindView(R.id.user_avator)
    SimpleDraweeView mUserAvator;
    @BindView(R.id.date)
    TextView mDate;

    public NoticeCardVHolder(ViewGroup parent, ViewComponent component) {
        super(LayoutInflater.from(parent.getContext()).inflate(R.layout.notice_card_view_holder, parent, false),
                component);
        ButterKnife.bind(this, itemView);
    }

    public void render(NoticesMessageDTO noticesMessageDTO) {
        ......
    }

    //文案拼接
    private void renderOperateView(NoticesMessageDTO.ContentObj contentObj, int readYn) {
        ......
    }

        protected void setItemReaded() {
        ......
    }
}
</code></pre><p><strong>3、BaseViewHolder作为onCreateViewHolder方法的返回值类型。</strong><br>BaseViewHolder作为ViewHolder的基类，可避免在onBindViewHolder中对ViewHolder进行类型检查与类型转换，简化了onBindViewHolder方法中的数据绑定与逻辑处理。</p>
<p>按以上实现思路，getItemViewType 、onCreateViewHolder和onBindViewHolder方法的代码将变得相对简单。如下</p>
<pre><code>@Override
public int getItemViewType(int position) {
    if (mNoticesMessageDTOs != null &amp;&amp; position &lt; mNoticesMessageDTOs.size()) {
        return mNoticesMessageDTOs.get(position).getEventType();
    }
}

public BaseVHolder onCreateViewHolder(ViewGroup parent, int viewType) { 
    BaseVHolder viewHolder = null;
    switch (viewType) {
            ......    
        case Constants.EventType.CARD_DELTE:
        case Constants.EventType.CARD_RESTORE:
        case Constants.EventType.CARD_MOVE:
        case Constants.EventType.CARD_RENAME:
            viewHolder = new NoticeCardVHolder(parent, mViewComponent);
            break;
        case Constants.EventType.DISCUSS_NEW_TOPIC:
        case Constants.EventType.DISCUSS_NEW_COMMIT:
        case Constants.EventType.DISCUSS_REPLY_COMMIT:
        case Constants.EventType.DISCUSS_AT_YOU:
            viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
            break;
        default:
            viewHolder = null;
            break;
    }
    return viewHolder;
}

@Override
public void onBindViewHolder(BaseVHolder holder, int position) {
    holder.render(mNoticesMessageDTOs.get(position));
} 
</code></pre><p>在onBindViewHolder中不需要对ViewHolder进行任何操作，数据的绑定和逻辑处理都交给对应的ViewHolder来处理，因此每个ViewHolder可根据实际情况实现render方法。这样所有的业务逻辑全部放在ViewHolder中，如果新增一种类型只需实现对应的ViewHolder，然后在onCreateViewHolder方法中创建ViewHolder类型即可，这样Adapter会便于扩展和维护。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>前面实现的Adapter只能处理通知相关类型，算不上真正的通用。如果应用场景发生变化，比如项目列表、文件记录或搜索结果列表等，此时所绑定的数据Model不再是通知类型，Adapter将无法适应这些情况。因此做了如下改造：</p>
<p><strong>1、定义通用的viewType类型。</strong></p>
<pre><code>/** 定义不同vholder类型 **/
public interface VHolderType {
    /** 通知相关 */
    int NoticeProjectAnounce = 101;
    int NoticeProjectApprove = 102;
    int NoticeProject = 103;
    int NoticeCard = 104;
    int NoticeLabel = 105;
    /** 搜索相关 **/
    int SearchCardHead = 201;
    int SearchCard = 202;
    int SearchFile = 203;
    int SearchFolder = 204;
    /** 项目相关 **/
    int ShowProject = 301;
}
</code></pre><p><strong>2、数据Model中增加type标识。</strong>前面介绍的viewType是由服务端控制，这里为兼容不同的数据Model，需要在本地统一配置管理，然后根据Model获得自定义viewType。</p>
<ul>
<li><p><strong>定义抽象接口</strong></p>
<pre><code>public interface TypeFactory {
    int type(NoticesMessageDTO noticesMessageDTO);
    int type(SearchResourceDTO searchResourceDTO);
    int type(ProjectInfoDTO projectInfoDTO);
}

//列表相关Model需实现该接口
public interface ViewModel {
    int type(TypeFactory typeFactory);
}
</code></pre></li>
</ul>
<ul>
<li><strong>实现ViewModel接口。</strong>不同类型的Model以List\<viewmodel\> 的形式放在列表中。</viewmodel\></li>
</ul>
<pre><code>public class SearchResourceDTO implements MessagesAdapter.ViewModel{
    ......
    @Override
    public int type(MessagesAdapter.TypeFactory typeFactory) {
        return  typeFactory.type(this);
    }
}

public class NoticesMessageDTO implements MessagesAdapter.ViewModel{
    ......
    @Override
    public int type(MessagesAdapter.TypeFactory typeFactory) {
        return typeFactory.type(this);
    }
}
</code></pre><p><strong>3、配置TypeFactory，将Model数据转化为通用viewType。</strong></p>
<pre><code>public static class TypeFactoryForList implements TypeFactory {
    @Override
    public int type(NoticesMessageDTO noticesMessageDTO) {
        int viewType = 0;
        if (noticesMessageDTO != null) {
            switch (noticesMessageDTO.getEventType()) {
                   ......

                case Constants.EventType.PROJECT_MODIFY_NOTICE: // 公告
                    viewType = Constants.VHolderType.NoticeProjectAnounce;
                    break;
                case Constants.EventType.PROJECT_MODIFY_NAME: // 项目信息更新1003
                    viewType = Constants.VHolderType.NoticeProject;
                    break;
                Constants.EventType.CARD_FOLLOW_CANCEL:
                case Constants.EventType.CARD_ADD_FOLLOW:
                case Constants.EventType.CARD_REMOVE_FOLLOW:
                case Constants.EventType.FILE_UPLOAD: // 文件
                case Constants.EventType.FILE_UPDATE:
                case Constants.EventType.FILE_DELETE:
                case Constants.EventType.FILE_RESTORE:
                Constants.EventType.FOLDER_UPLOAD: // 文件夹
                case Constants.EventType.FOLDER_CREATE:
                case Constants.EventType.FOLDER_RESTORE:
                case Constants.EventType.FOLDER_DELETE:
                    viewType = Constants.VHolderType.NoticeCard;
                    break;
                //讨论标注相关
                case Constants.EventType.DISCUSS_NEW_TOPIC:
                case Constants.EventType.DISCUSS_NEW_COMMIT:
                case Constants.EventType.DISCUSS_REPLY_COMMIT:
                case Constants.EventType.DISCUSS_AT_YOU:
                    viewType = Constants.VHolderType.NoticeLabel;
                    break;
            }
        }
        return viewType;
    }

    public int type(SearchResourceDTO searchResourceDTO) {
        int viewType = 0;
        if (searchResourceDTO != null) {
            switch (searchResourceDTO.getResType()) {
                case Constants.SearchResultType.RES_CARD_HEAD:
                    viewType = Constants.VHolderType.SearchCardHead;
                    break;
                case Constants.SearchResultType.RES_CARD:
                    viewType = Constants.VHolderType.SearchCard;
                    break;
                case Constants.SearchResultType.RES_FILE:
                    viewType = Constants.VHolderType.SearchFile;
                    break;
                case Constants.SearchResultType.RES_FOLDER:
                    viewType = Constants.VHolderType.SearchFolder;
            }
        }
        return viewType;
    }

    public int type(ProjectInfoDTO projectInfoDTO) {
        return Constants.VHolderType.ShowProject;
    }
}
</code></pre><p>将类型判断抽取到TypeFactoryForList中，减轻了onCreateViewHolder方法的代码量，同时便于对各种类型进行统一管理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过改进后的Adapter代码如下：</p>
<pre><code>public class MessagesAdapter extends RecyclerView.Adapter&lt;BaseVHolder&gt; {
    private List&lt;ViewModel&gt; mMessageDTOs;

    private ViewComponent mViewComponent;

    public MessagesAdapter(ViewComponent component) {
        mViewComponent = component;
        mMessageDTOs = new ArrayList&lt;ViewModel&gt;();
    }

    @Override
    public int getItemViewType(int position) {
        return mMessageDTOs.get(position).type(new TypeFactoryForList());
    }

    @Override
    public BaseVHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        BaseVHolder viewHolder = null;
        switch (viewType) {
            ......
            case Constants.VHolderType.NoticeProjectAnounce: 
                viewHolder = new NoticeProjectAnounceVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeProjectApprove:
                viewHolder = new NoticeProjectApproveVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeProject:
                viewHolder = new NoticeProjectVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeCard:
                viewHolder = new NoticeCardVHolder(parent, mViewComponent);
                break;
            case Constants.VHolderType.NoticeLabel:
                viewHolder = new NoticeLabelVHolder(parent, mViewComponent);
                break;
        }
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(BaseVHolder holder, int position) {
        holder.render(mMessageDTOs.get(position));
    }
     ......
}
</code></pre><p>将原本应该在Adapter中实现的代码抽离出来，让Adapter更加简洁，更多的逻辑放在ViewHolder和TypeFactory中，数据列表的Item更加独立，甚至可以让不同Model数据混合显示。具有较强的通用性，<br>能够实现列表页面的快速复制。<br>但是还存在一些不足，比如BaseViewHolder中的render方法可能还需要扩展，才能更好的满足多Model情况下的数据绑定与逻辑处理，大家可以根据实际情况进行修改。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" target="_blank" rel="external">https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html</a></p>
<p><a href="http://www.jianshu.com/p/c6a44e18badb" target="_blank" rel="external">http://www.jianshu.com/p/c6a44e18badb</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/16/代码规范检查/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/16/代码规范检查/" itemprop="url">
                  代码规范检查
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-16T19:03:56+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了保证团队内部代码风格的统一，提升代码的质量，更好的遵循标准的编写规范。必须定义一个统一的规范，在执行上前期主要由团队的老司机进行codereview，并对review出来的问题进行总结和回顾，避免后期犯类似的错误。但是这样会加大老司机的工作量，降低整个团队的工作效率，如果项目周期比较赶可能会放松对代码的要求。因此，有必要引入自动化工具来帮助我们保证代码的质量，这里主要采用两种办法：</p>
<ul>
<li><p><strong>coding阶段</strong>：为IDE配置统一的格式化模板，在完成开发后手动进行format。具体配置方式参见<a href="http://note.youdao.com/groupshare/?token=A0EFFF04E19246089EAFACD7A818FEF0&amp;gid=30539562" target="_blank" rel="external">Android端Code Style统一规范</a></p>
</li>
<li><p><strong>build阶段</strong>：使用checkstyle工具检查代码，注释、命名规范、方法长度、空格缩进等不再需要手工检查，由于标准的check过于严格，可以根据实际情况取消部分检查规则。对于不符合规范的代码，警告或者错误提示。</p>
</li>
</ul>
<h1 id="Checkstyle配置"><a href="#Checkstyle配置" class="headerlink" title="Checkstyle配置"></a>Checkstyle配置</h1><p>具体的配置步骤：</p>
<p>1、将自定义的checkstyle.xml文件放在项目/setting目录下.</p>
<p>2、添加checkstyle任务，并配置检查项目。</p>
<pre><code>allprojects{
   repositories{ 
         jcenter()
 }
 task checkstyle(type: Checkstyle) {
       showViolations = true
       configFile file(&quot;../settings/checkstyle.xml&quot;)
       source &apos;src/main/java&apos;//检查Java代码
       include &apos;**/*.java&apos;  //不检查
       exclude &apos;**/gen/**&apos;
       exclude &apos;**/R.java&apos;
       exclude &apos;**/BuildConfig.java&apos;

       // empty classpath
       classpath = files()
       ignoreFailures true     // 忽略检查失败的情况，避免gradle命令执行中止
   }
}
</code></pre><p>3、在module的build.gradle中添加checkstyle插件，并声明checkstyle任务的执行条件。</p>
<pre><code>apply plugin: &apos;checkstyle&apos;

preBuild.dependsOn(&apos;checkstyle&apos;)
assemble.dependsOn(&apos;lint&apos;)
check.dependsOn(&apos;checkstyle&apos;)
</code></pre><p>4、在终端中执行如下命令，可在/app/build/reports中看到生成的警示报告文件。</p>
<pre><code>./gradlew checkstyle 
</code></pre><h1 id="自定义xml配置文件"><a href="#自定义xml配置文件" class="headerlink" title="自定义xml配置文件"></a>自定义xml配置文件</h1><p>IDE的Code Style Format包括如下几个部分：</p>
<ul>
<li>Tabs and Indents</li>
<li>Spaces</li>
<li>Wrapping and braces</li>
<li>Blank lines</li>
<li>JavaDoc</li>
<li>Arrangement</li>
<li>Imports</li>
<li>Code Generation</li>
</ul>
<p>可以直接在IntelliJ IDEA中勾选设置，然后导出配置文件，共享给团队成员。但它只能对代码的格式进行自动调整，无法检查代码的问题和错误。Checkstyle插件是在format的基础上，对代码的格式和语法进行检查和分析，包括下面几大类型：</p>
<ul>
<li>Javadoc Comments </li>
<li>Naming Conventions</li>
<li>Imports</li>
<li>Size Violations</li>
<li>Whitespace</li>
<li>ModifierOrder</li>
<li>Block Checks</li>
<li>Coding</li>
<li>Class Design</li>
<li>Duplicate Code</li>
<li>Miscellaneous</li>
</ul>
<p>根据项目实际情况，主要对Javadoc注释、命名规范、import语句、代码块、缩进和空行以及风格、类设计、重复代码等分析规则进行配置。<br>具体配置文件如下<a href="https://github.com/checkstyle/checkstyle/blob/master/config/checkstyle_checks.xml" target="_blank" rel="external">checkstyle.xml</a></p>
<blockquote>
<p>这里参照了官方提供的配置文件<a href="https://github.com/checkstyle/checkstyle/blob/master/config/checkstyle_checks.xml" target="_blank" rel="external">checkstyle_checks.xml</a>，并加以详细的注释，可根据实际需求添加或移除module。</p>
</blockquote>
<h1 id="自定义文件说明"><a href="#自定义文件说明" class="headerlink" title="自定义文件说明"></a>自定义文件说明</h1><p>Checkstyle配置文件通过指定modules应用到java文件。modules是树状结构，以一个名为Checker的module作为root节点，一般的checker都会包括TreeWalker子module。</p>
<blockquote>
<p>xml配置文件中通过module的name属性来区分module，module的Properties可以控制如何去执行这个module，每个property都有一个默认值，所有的check都有一个severity属性，用它来指定check的level。TreeWalker为每个java文件创建一个语法树，在节点之间调用submodules的Checks。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/28/如何实现多样式富文本/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/28/如何实现多样式富文本/" itemprop="url">
                  如何实现多样式富文本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-28T12:55:55+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目中需要使用富文本来显示消息通知，由于消息的类型多达几十种，且这些不同类型消息显示的文案由服务端控制，这里文案需要使用富文本来显示不同颜色、大小、字体的文字，所幸是textView支持富文本显示。具体实现方法有两种。</p>
<h2 id="使用HTML-标记设置样式"><a href="#使用HTML-标记设置样式" class="headerlink" title="使用HTML 标记设置样式"></a>使用HTML 标记设置样式</h2><p>将待显示字符串添加到strings文件中。例如：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;string name=&quot;welcome&quot;&gt;Welcome to&lt;b&gt;Android&lt;/b&gt;!&lt;/string&gt;
&lt;/resources&gt;
</code></pre><p>支持的 HTML 标签包括：</p>
<pre><code>&lt;a href=&quot;...&quot;&gt;创建超文本链接

&lt;b&gt;黑体字

&lt;big&gt;字体加大

&lt;blockquote&gt;从两边缩进文本

&lt;br&gt;换行插入换行符

&lt;cite&gt;引用，通常是斜体

&lt;dfn&gt;述语定义

&lt;div align=&quot;...&quot;&gt;用来排版大块HTML段落,也用于格式化表

&lt;em&gt;强调文本(通常是斜体加黑体)

&lt;font size=&quot;...&quot; color=&quot;...&quot;face=&quot;...&quot;&gt;设置字体大小从1到7，颜色使用名字或RGB的十六进制值

&lt;h1&gt;至&lt;h6&gt;标题

&lt;i&gt;斜体字

&lt;img src=&quot;...&quot;&gt;图片

&lt;p&gt;创建一个段落

&lt;small&gt;字体缩小

&lt;strike&gt;加删除线

&lt;strong&gt;加重文本(通常是斜体加黑体)

&lt;sub&gt;下标字

&lt;sup&gt;上标字

&lt;tt&gt;打字机风格的字体

&lt;u&gt;下划线
</code></pre><p>如果将带样式文本资源作为格式字符串。 正常情况下是行不通的，因为 String.format(String,Object…) 方法会去除字符串中的所有样式信息。要解决这个问题只能编写带转义实体的 HTML 标签，在完成格式设置后，这些实体可通过fromHtml(String) 恢复。 例如：</p>
<p><strong>1.将您带样式的文本资源存储为HTML 转义字符串：</strong></p>
<pre><code>&lt;resources&gt;
  &lt;string name=&quot;welcome_messages&quot;&gt;Hello, %1$s! You have &amp;lt;b&gt;%2$d newmessages&amp;lt;/b&gt;.&lt;/string&gt;
&lt;/resources&gt;
</code></pre><p>在这个带格式的字符串中，添加了 \<b> 元素。请注意，开括号使用 \&lt; 表示法进行了 HTML 转义。</b></p>
<p><strong>2.然后照常设置字符串格式，但还要调用 <a href="https://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String" target="_blank" rel="external">fromHtml(String)</a>) 以将HTML 文本转换成带样式文本：</strong></p>
<pre><code>Resources res = getResources();
String text =String.format(res.getString(R.string.welcome_messages), username, mailCount);
CharSequence styledText = Html.fromHtml(text);
</code></pre><p>由于 fromHtml(String) 方法将设置所有 HTML 实体的格式，因此务必要使用 htmlEncode(String) 对您用于带格式文本的字符串中任何可能的 HTML 字符进行转义。 例如，如果您向 String.format() 传递的字符串参数可能包含“&lt;”或“&amp;”之类的字符，则必须在设置格式前进行转义，这样在通过 fromHtml(String) 传递带格式字符串时，字符就能以原始形式显示出来。 例如：</p>
<pre><code>String escapedUsername = TextUtil.htmlEncode(username);
Resources res =getResources();
String text =String.format(res.getString(R.string.welcome_messages), escapedUsername, mailCount);
CharSequence styledText = Html.fromHtml(text);
</code></pre><h2 id="使用Spannable-设置样式"><a href="#使用Spannable-设置样式" class="headerlink" title="使用Spannable 设置样式"></a>使用Spannable 设置样式</h2><p><a href="https://developer.android.com/reference/android/text/Spannable.html" target="_blank" rel="external">Spannable</a>可以对颜色和字体粗细等属性进行样式设置。 首先使用 SpannableStringBuilder 构造文本内容，然后为文本设置 android.text.style 包中定义的样式，常见的样式有StrikethroughSpan、StyleSpan、ForegroundColorSpan等。例如，为某段文字内容加上带颜色和删除线的粗体样式。</p>
<pre><code>public CharSequence renderSpan(Stringtext, String color, boolean isBold, boolean isDelete) {
    if(TextUtils.isEmpty(color)) {
        color =&quot;#272934&quot;;//默认值
    }
    if(TextUtils.isEmpty(text)) {
        return null;
    }
   SpannableStringBuilder span = new SpannableStringBuilder();
   span.append(text);
    if(isDelete) {
        StrikethroughSpanstrikethroughSpan = new StrikethroughSpan();
        span.setSpan(strikethroughSpan,0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    if (isBold){
        StyleSpanboldStyle = new StyleSpan(Typeface.BOLD);
        span.setSpan(boldStyle,0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    span.setSpan(newForegroundColorSpan(Color.parseColor(color)), 0,text.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    returnspan;
</code></pre><p>}</p>
<p>最后，项目中用到了格式化字符串，所以只能采取第一种方式来避免样式信息被清除。这里遇到一个非常奇葩的坑， fromHtml(String)无法正常显示带\<strike>标签的格式。解决办法是结合使用spannable，如下：</strike></p>
<pre><code>public CharSequence renderSpan(String text,String color, boolean isBold, boolean isDelete) {
   if(TextUtils.isEmpty(color)) {
       color =&quot;#272934&quot;;
   }
   if(TextUtils.isEmpty(text)) {
       returnspan;
   }
   SpannableStringBuilder span = new SpannableStringBuilder();
   span.append(text);
   if(isDelete) {
      span.insert(0, &quot;&lt;strike&gt;&quot;);
      span.append(&quot;&lt;/strike&gt;&quot;);
   }
   if (isBold){
      span.insert(0, &quot;&lt;b&gt;&quot;);
      span.append(&quot;&lt;/b&gt;&quot;);
   }
  //span.insert(0, &quot;&lt;font color=\&quot;&quot; + color +&quot;\&quot;&gt;&quot;);
  //span.append(&quot;&lt;/font&gt;&quot;);
   return span;
}




   Resources res = getResources();
   String text = String.format(res.getString(R.string.welcome_messages),renderSpan(escapedUsername ,&quot;&quot;,true,true));    
   SpannableStringBuilder operateStr =new  SpannableStringBuilder(text);
   Object[]spans = operateStr.getSpans(0, operateStr.length(), Object.class);
   if (spans.length &gt; 0) {
       for(Object object : spans) {
           intstart = operateStr.getSpanStart(object);
           intend = operateStr.getSpanEnd(object);
           StrikethroughSpan strikethroughSpan = new StrikethroughSpan();
           operateStr.setSpan(strikethroughSpan, start, end,Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
           break;
       }

   }
</code></pre><p>这里通过其他span对象来确定样式字符串的位置，然后采用第二种方式进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/22/Android图片缓存分析与优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="潘威">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/22/Android图片缓存分析与优化/" itemprop="url">
                  Android图片缓存分析与优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-22T20:14:23+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近分析线上日志，发现存在一定量的OutOfMemoryError。由于Android系统对堆内存大小作了限制，不同的设备上这个阈值也会不同，当已分配内存加新分配内存大于堆内存就会导致OOM。虽然Android机型的配置在不断升级，但还是存在着几年前的旧机型，它们的特点是内存小，尤其在涉及大图片加载时很容易出现OOM。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了避免OOM，程序应该增加可用内存，并及时回收不再使用的对象，降低内存占用。可以从以下几个方面去考虑：</p>
<p><strong>1、对图片进行处理，如图片裁剪和压缩。</strong></p>
<p>使用缩略图来提高加载速度和降低内存占用。根据控件大小对图片进行裁剪，减少不必要内存浪费。我们的项目中使用了NOS提供的图片处理服务，它提供了非常强大的云处理功能，在开发过程中根据实际需要生成请求链接，获取不同尺寸的图片，实现图片裁剪。同时使用BitmapFactory.Options属性，通过设置采样率, 减少Bitmap的像素。</p>
<p><strong>2、内存引用上做一些处理，常用的有软引用。</strong></p>
<p>使用软引用的对象在内存足够时，垃圾回收器不会回收它；当内存空间不足时，为满足程序运行的需求，会回收这些对象，避免出现OOM导致的程序崩溃。因此只要对象没有被回收都能被程序使用。过去很多应用都大量使用软引用进行图片缓存，通过GC自动回收图片所占内存。下图是谷歌对图片缓存的说明：        </p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%8A%E7%AB%AF.jpg" alt="软引用"></p>
<p>从上图可以看出，从Android 2. 3开始，垃圾回收器会更倾向于回收持有软引用或弱引用的对象，这让软引用和弱引用变得不再可靠。另外，在Android 3.0中，图片的数据会存储在本地的内存当中，因而无法用一种可预见的方式将其释放，这就有潜在的风险造成应用程序的内存溢出并崩溃，所以在开发过程中要谨慎使用。</p>
<p><strong>3、缓存机制。</strong></p>
<p>缓存不仅可以减少流量的浪费还能防止加载过多的图片，项目中使用了比较主流的内存、文件和网络三级缓存。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.jpg" alt="三级缓存"></p>
<p>通过URL向网络请求图片时，先从内存中查找，如果内存中没有，再从缓存文件中查找，如果缓存文件中也没有，再向网络发Http请求下载图片，然后再依次缓存在内存和文件中。</p>
<p>在项目中使用了强引用（LRUCache）与软引用相结合的方式进行内存缓存。系统不会回收强引用的对象，为了防止OOM，需要为LRUCache设置适当的大小，并及时回收内存。因为堆空间又被分为年轻代、老年代和永久代，新分配的对象会先放在年轻代中，当停留一段时间后，这个对象会被移动到老年代，最后再移动到永久代中。系统的每一个内存区域都采用不同的策略进行GC操作，年轻代的对象更容易被销毁，而且GC操作的速度比老年代的速度要快，时间更短。</p>
<p>同时Android系统并不会对空闲内存区域做碎片整理，只有在内存不足时触发GC进行回收，从而造成空间上的浪费。因此，程序应该在适当的时候主动回收不再使用的图片，减少被动回收导致的内存溢出风险。</p>
<p><strong>4、自定义堆内存大小，如使用largeHeap。</strong></p>
<p>在Manifest.xml中的Application节点下加入android:largeHeap=”true”，系统便能为应用程序分配更多的内存空间，但是这种方式不能根本解决问题，不合理的使用内存同样会造成OOM，只是延缓其发生。对于一些内存占用比较大的图片、视频类应用，最好在开发测试过后再加上该属性。</p>
<p><strong>5、使用第三方开源图片框架</strong>，比如Picasso、Glide、Fresco等，它们在图片异步加载、缓存、内存管理和优化等方面已经做了很好的处理。</p>
<h1 id="基于LRUCache的缓存"><a href="#基于LRUCache的缓存" class="headerlink" title="基于LRUCache的缓存"></a>基于LRUCache的缓存</h1><p>前面介绍了几种避免OOM的方式，在实际项目中需要结合使用。本文主要介绍内存缓存的实现，包括强引用缓存和软引用缓存两个部分。强引用缓存采用LRUCache实现,它是Android系统为开发人员提供的缓存工具类，实际上是将强引用的对象存储在LinkedHashMap中，初始化时会设置缓存空间大小，当缓存数据达到预设值时会采用最近最少使用算法进行淘汰。另外，软引用缓存同样使用LinkedHashMap作为存储结构，将从LRUCache淘汰的数据扔到软引用缓存中，之前的做法是对软引用对象不做任何处理，等待垃圾回收器自动回收。大量使用软引用的弊端前面也有介绍，本文对此做了部分改进，有限的使用软引用对象，当软引用缓存空间不足时，同样按照LRU规则淘汰并主动回收内存空间。</p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/lru%E7%BC%93%E5%AD%98.jpg" alt="LRU缓存">      </p>
<p>首先，通过图片的URL从网络下载图片，将图片先缓存到内存缓存中，缓存到强引用也就是LruCache中。如果LruCache空间不足，就会将较早存储的图片对象淘汰到软引用缓存中，然后将图片缓存到文件中。在读取图片时，先读取内存缓存，判断LruCache是否存在图片，如果存在，则直接读取，如果LruCache中不存在，则判断软引用中是否存在，如果软引用中存在，则将软引用中的图片添加到LruCache并且删除软引用中的数据，如果软引用中不存在，则从文件或网络读取。</p>
<h1 id="代码分析与实现"><a href="#代码分析与实现" class="headerlink" title="代码分析与实现"></a>代码分析与实现</h1><p>首先，通过继承LRUCache类实现BitmapLRUCache，里面的键值对分别是URL和对应图片的Drawable对象。</p>
<pre><code>class BitmapLRUCache extends LruCache&lt;String, Drawable&gt;
</code></pre><p>然后在构造方法中初始化软引用缓存mSoftBitmapCache，并设置LRUCache的大小，这里设置为手机可用内存的1/4。</p>
<pre><code>int maxMemory=(int)Runtime.getRuntime().maxMemory()/4;
</code></pre><p>通过LRUCache构造方法的源码可以看出，实际上是初始化一个LinkedHashMap，并且LinkedHashMap中的对象采用LRU规则自动排序。</p>
<pre><code>public LruCache(int maxSize) {
    ... ...
    this.maxSize = maxSize;
    this.map = new LinkedHashMap(0, 0.75f, true);
}
public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {
    super(initialCapacity, loadFactor);
    init();
    this.accessOrder = accessOrder;
}
</code></pre><p>在LruCache中初始化LinkedHashMap构造方法的accessOrder参数值为true，这个参数默认为false，表示对象按照插入顺序排序。下面是LruCache类的get方法：</p>
<pre><code> public V get(Object key) {
    ... ...
    for (HashMapEntry e = tab[hash &amp; (tab.length - 1)];
            e != null; e = e.next) {
        K eKey = e.key;
        if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) {
            if (accessOrder)
                makeTail((LinkedEntry) e);
            return e.value;
        }
    }
    return null;
}
</code></pre><p>当向缓存get数据时，如果accessOrder为true，则通过makeTail((LinkedEntry) e)方法将对象移到了末尾， 这样就能够保证每次从头部移除最近最少使用的对象。<br>        如果向LRUCache中插入图片对象，当缓存空间不足时，需要移除最近最少使用对象，由于LinkedHashMap已经做好了排序， 所以直接移除头部对象即可。<br>       下面是LRUCache的put方法：</p>
<pre><code>public final V put(K key, V value) {
   ... ...
    V previous;
    synchronized (this) {
        putCount++;
        size += safeSizeOf(key, value);
        previous = map.put(key, value);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }
    if (previous != null) {
        entryRemoved(false, key, previous, value);
    }
    trimToSize(maxSize);
    return previous;
}
</code></pre><p>其中safeSizeOf(key, value)用来获取待插入对象的大小，并对已占用内存进行累加。再看看这个方法：</p>
<pre><code>private int safeSizeOf(K key, V value) {
    int result = sizeOf(key, value);
    if (result &lt; 0) {
        throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);
    }
    return result;
}
</code></pre><p>返回的result通过sizeOf(key, value)这个方法获取，到这里我们明白了需要重写sizeOf方法， 这里用每行像素点所占用的字节数乘高度计算出图片大小。</p>
<pre><code>protected int sizeOf(String key, Drawable value) {
   if(value!=null) {
      if (value instanceof BitmapDrawable) {
         Bitmap bitmap = ((BitmapDrawable) value).getBitmap();
         return bitmap.getRowBytes() * bitmap.getHeight();
      } 
      return 1;
   }else{
      return  0;
   }
}
</code></pre><p>然而真正移除对象是在trimToSize(maxSize)这个方法中：</p>
<pre><code>public void trimToSize(int maxSize) {
    while (true) {
        K key;
        V value;
        synchronized (this) {
            ... ...
            if (size &lt;= maxSize || map.isEmpty()) {
                break;
            }
            Map.Entry toEvict = map.entrySet().iterator().next();
            key = toEvict.getKey();
            value = toEvict.getValue();
            map.remove(key);
            size -= safeSizeOf(key, value);
            evictionCount++;
        }
        entryRemoved(true, key, value, null);
    }
}
</code></pre><p>这里会检查当前缓存容量，size &lt;= maxSize便移除头部对象。最后调用了entryRemoved(true, key, value, null)方法。</p>
<p>因此，我们可以重写该方法来处理淘汰对象：</p>
<pre><code>protected void entryRemoved(boolean evicted, String key, Drawable oldValue, Drawable newValue) {
   if (evicted) {
      if (oldValue != null) {
         //当硬缓存满了,根据LRU规则移入软缓存
         synchronized(mSoftBitmapCache) {
            mSoftBitmapCache.put(key, new SoftReference(oldValue));
         }
      }
   }else{//主动移除,回收无效空间
      recycleDrawable(oldValue);
   }
}
</code></pre><p>当evicted变量为true时，属于为腾出缓存空间被调用，将被淘汰的对象插入软引用缓存mSoftBitmapCache中。</p>
<p>当evicted变量为false时，属于主动淘汰对象，看下面代码：</p>
<pre><code>public final V remove(K key) {
    ... ...
    V previous;
    synchronized (this) {
        previous = map.remove(key);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }
    if (previous != null) {
        entryRemoved(false, key, previous, null);
    }
    return previous;
}
</code></pre><p>entryRemoved方法在LRUCache的remove方法中调用时，evicted参数的值为false，因此这里直接回收图片对象。 </p>
<p>如果软引用缓存mSoftBitmapCache超出上限，也根据LRU规则进行淘汰，直接回收对象的内存空间。这里参考LRUCache的实现方式进行初始化：</p>
<pre><code>this.mSoftBitmapCache= new LinkedHashMap&gt;(SOFT_CACHE_SIZE, 0.75f, true){ 
   @Override
   protected boolean removeEldestEntry(Entry&gt; eldest) {
      if (size() &gt; SOFT_CACHE_SIZE) {//缓存数量不超过10
         if(eldest!=null){
            SoftReference bitmapReference=eldest.getValue();
            if(bitmapReference!=null){
               Drawable oldValue=bitmapReference.get();
               recycleDrawable(oldValue);
            }
         }
         return true;
      }
      return false;
   }
};
</code></pre><p>不同的是重写了removeEldestEntry方法，这个方法主要用于判断缓存容量是否超过上限，如果超出则回收被淘汰的对象。</p>
<p>再看看LinkedHashMap类的put方法调用了addNewEntry方法，在该方法中会根据removeEldestEntry方法的返回来决定是否移除对象：</p>
<pre><code>public V put(K key, V value) {
        ... ...
    addNewEntry(key, value, hash, index);
    return null;
}
void addNewEntry(K key, V value, int hash, int index) {
    LinkedEntry header = this.header;
    // Remove eldest entry if instructed to do so.
    LinkedEntry eldest = header.nxt;
    if (eldest != header &amp;&amp; removeEldestEntry(eldest)) {
       remove(eldest.key);
    }
        ......
}
</code></pre><p>因此，当size() &gt; SOFT_CACHE_SIZE时，便对老对象进行移除操作。 从缓存中获取对象的方法：</p>
<pre><code>public Drawable getBitmap(String url){
  // 先从硬缓存中获取
  Drawable bitmap = get(url);
  if (bitmap != null) {
     return bitmap;
  }
  synchronized (mSoftBitmapCache) {
     SoftReference bitmapReference = mSoftBitmapCache.get(url);
     if (bitmapReference != null) {
        bitmap = bitmapReference.get();
        if (bitmap != null) {
           //移入硬缓存
           put(url, bitmap);
           mSoftBitmapCache.remove(url);
           return bitmap;
        } else {
           mSoftBitmapCache.remove(url);
        }
     }
  }
  return null;
}
</code></pre><p>优先从硬缓存中拿，如果存在则返回。否则查询软引用缓存，存在则返回对象并移入硬缓存中。</p>
<p>最后上完整的代码：</p>
<pre><code>public class BitmapLRUCache extends LruCache {
   private final int SOFT_CACHE_SIZE = 10; // 软引用缓存容量
   private LinkedHashMap&gt; mSoftBitmapCache;//软引用缓存,已清理的数据可能会再次使用
   public BitmapLRUCache(int maxSize) {
      super(maxSize);
      this.mSoftBitmapCache= new LinkedHashMap&gt;(SOFT_CACHE_SIZE, 0.75f, true){// true 采用LRU排序,移除队首
         @Override
         protected boolean removeEldestEntry(Entry&gt; eldest) {
            if (size() &gt; SOFT_CACHE_SIZE) {//缓存数量不超过10
               if(eldest!=null){
                  SoftReference bitmapReference=eldest.getValue();
                  if(bitmapReference!=null){
                     Drawable oldValue=bitmapReference.get();
                     recycleDrawable(oldValue);
                  }
               }
               return true;
            }
            return false;
         }
      };
   }
   public Drawable getBitmap(String url){
      // 先从硬缓存中获取
      Drawable bitmap = get(url);
      if (bitmap != null) {
         return bitmap;
      }
      synchronized (mSoftBitmapCache) {
         SoftReference bitmapReference = mSoftBitmapCache.get(url);
         if (bitmapReference != null) {
            bitmap = bitmapReference.get();
            if (bitmap != null) {
               //移入硬缓存
               put(url, bitmap);
               mSoftBitmapCache.remove(url);
               return bitmap;
            } else {
               mSoftBitmapCache.remove(url);
            }
         }
      }
      return null;
   }
   private  int getSizeInBytes(Bitmap bitmap) {
      int size = bitmap.getRowBytes() * bitmap.getHeight();//每一行像素点所占用的字节数 *  高度
      return size;
   }
   protected int sizeOf(String key, Drawable value) {
      if(value!=null) {
         if (value instanceof BitmapDrawable) {
            Bitmap bitmap = ((BitmapDrawable) value).getBitmap();
            return getSizeInBytes(bitmap);
         }
         return 1;
      }else{
         return  0;
      }
   }
   protected void entryRemoved(boolean evicted, String key, Drawable oldValue, Drawable newValue) {
      super.entryRemoved(evicted, key, oldValue, newValue);
      if (evicted) {
         if (oldValue != null) {
            //当硬缓存满了,根据LRU规则移入软缓存
            synchronized(mSoftBitmapCache) {
               mSoftBitmapCache.put(key, new SoftReference(oldValue));
            }
         }
      }else{//主动移除,回收无效空间
         recycleDrawable(oldValue);
      }
   }
   private void recycleDrawable(Drawable oldValue) {
      if (oldValue != null) {
         try {
            if (oldValue instanceof BitmapDrawable) {
               Bitmap bitmap = ((BitmapDrawable) oldValue).getBitmap();
               bitmap.recycle();
            }
            Log.i(&quot;BitmapLRUCache&quot;, &quot;oldValue：&quot; + oldValue);
         } catch (Exception exception) {
            Log.i(&quot;BitmapLRUCache&quot;, &quot;Failed to clear Bitmap images on close&quot;, exception);
         } finally {
            oldValue = null;
         }
      }
   }
}
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试机器为华为G525,系统版本为4.1。运行改进后的代码，在AndroidStudio中查看Monitors栏，启动程序并进行简单操作，很清楚的看到内存占用的实时变化以及释放的过程。</p>
<p><strong>改进前：</strong></p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/%E4%BC%98%E5%8C%96%E5%89%8D.jpg" alt="改进前"> </p>
<p><strong>改进后:</strong></p>
<p><img src="https://raw.githubusercontent.com/panweiwork/MyImage/master/photocache/%E4%BC%98%E5%8C%96%E5%90%8E.jpg" alt="改进后"> </p>
<p>改进前内存保持在30M到40M之间，并且通过log日志观察GC暂停时间相对较长。改进后内存保持在20M以下。测试结果，有效的降低了内存占用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>应用程序过高的内存占用，资源不能及时释放，容易导致OOM。但内存占用也不是越少就越好，如果为了保持较低的内存占用而频繁触发GC操作，可能会造成程序性能的整体下降。因此，需要在实践中进行综合考虑做一定的权衡。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.jianshu.com/p/f5d8d3066b36" target="_blank" rel="external">http://www.jianshu.com/p/f5d8d3066b36</a></p>
<p><a href="https://my.oschina.net/u/586684/blog/226056" target="_blank" rel="external">https://my.oschina.net/u/586684/blog/226056</a></p>
<p><a href="http://www.bozhiyue.com/anroid/boke/2016/0521/132735.html" target="_blank" rel="external">http://www.bozhiyue.com/anroid/boke/2016/0521/132735.html</a></p>
<p><a href="http://blog.chinaunix.net/uid-26930580-id-4138306.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26930580-id-4138306.html</a></p>
<p><a href="https://developer.android.com/index.html" target="_blank" rel="external">https://developer.android.com/index.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpeg"
               alt="潘威" />
          <p class="site-author-name" itemprop="name">潘威</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潘威</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


</body>
</html>
